<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VRM Display</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: transparent !important;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #subtitle-container {
            position: fixed;
            bottom: 30%;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 8px;
            font-size: 18px;
            max-width: 80%;
            text-align: center;
            word-wrap: break-word;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            display: none;
            z-index: 1000;
            cursor: move;
            user-select: none;
        }

        #connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 20px;
            font-size: 14px;
            z-index: 1001;
        }

        .status-connected {
            background: rgba(34, 197, 94, 0.8) !important;
        }

        .status-disconnected {
            background: rgba(239, 68, 68, 0.8) !important;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-align: center;
            z-index: 999;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="subtitle-container"></div>
    <!-- <div id="connection-status">ÈÄ£Á∑ö‰∏≠...</div> -->
    <div id="loading">
        <div class="spinner"></div>
        <div>ËºâÂÖ•‰∏≠...</div>
    </div>

    <!-- Three.js Âíå VRM Áõ∏ÈóúÂ∫´ -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/",
            "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3.1.6/lib/three-vrm.module.min.js",
            "@pixiv/three-vrm-animation": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm-animation@3.1.6/lib/three-vrm-animation.module.min.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { VRMAnimationLoaderPlugin, createVRMAnimationClip } from '@pixiv/three-vrm-animation';

        // ============= ÂÖ®Â±ÄËÆäÈáè =============
        let scene, camera, renderer, controls;
        let currentVrm = null;
        let currentMixer = null;
        let clock = new THREE.Clock();
        let ws = null;
        let audioContext = null;
        let currentAudio = null;
        let subtitleElement = null;
        let statusElement = null;
        let loadingElement = null;

        // Èü≥È¢ëÊí≠ÊîæÈòüÂàóÂèòÈáè
        let audioQueue = [];
        let isPlayingAudio = false;

        // ============= ÂãïÁï´Á≥ªÁµ±ËÆäÈáè =============
        let isVRM1 = true;
        let idleAction = null;
        let breathAction = null;
        let blinkAction = null;
        let idleAnimationManager = null;
        let useVRMAIdleAnimations = true;
        let idleAnimations = [];
        let isLoadingAnimations = false;
        let isIdleAnimationModeChanging = false;

        // Èó≤ÁΩÆÂä®‰ΩúÁöÑÊó∂Èó¥ÂÅèÁßªÈáèÔºåËÆ©ÂêÑ‰∏™Âä®‰Ωú‰∏çÂêåÊ≠•
        const idleOffsets = {
            body: Math.random() * Math.PI * 2,
            leftArm: Math.random() * Math.PI * 2,
            rightArm: Math.random() * Math.PI * 2,
            head: Math.random() * Math.PI * 2,
            spine: Math.random() * Math.PI * 2
        };

        // ============= ÂàùÂßãÂåñÂ†¥ÊôØ =============
        function initScene() {
            const container = document.getElementById('canvas-container');
            
            // Â†¥ÊôØ
            scene = new THREE.Scene();
            scene.background = null;

            // Áõ∏Ê©ü
            camera = new THREE.PerspectiveCamera(
                30,
                window.innerWidth / window.innerHeight,
                0.1,
                20
            );
            camera.position.set(0, 1.3, 2);

            // Ê∏≤ÊüìÂô®
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.max(1, window.devicePixelRatio));
            renderer.setClearColor(0x000000, 0);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // ÊéßÂà∂Âô®
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 1.3, 0);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.update();

            // ÁáàÂÖâ
            const light = new THREE.DirectionalLight(0xffffff, Math.PI);
            light.position.set(1, 3, 2).normalize();
            light.castShadow = true;
            light.shadow.mapSize.set(2048, 2048);
            scene.add(light);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
            scene.add(ambientLight);

            // Âú∞Êùø - ‰ΩøÁî®ÈÄèÊòéÈò¥ÂΩ±ÊùêË¥®
            const groundGeo = new THREE.PlaneGeometry(20, 20);
            const shadowMat = new THREE.ShadowMaterial({ opacity: 0.4 });
            const ground = new THREE.Mesh(groundGeo, shadowMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Â≠óÂπïÂÖÉÁ¥†
            subtitleElement = document.getElementById('subtitle-container');
            // statusElement = document.getElementById('connection-status');
            loadingElement = document.getElementById('loading');

            // Â≠óÂπïÊãñÊõ≥ÂäüËÉΩ
            initSubtitleDrag();

            // ÈüøÊáâÂºè
            window.addEventListener('resize', onWindowResize);
        }

        // ============= Ëá™ÁÑ∂ÂßøÂã¢Ë®≠ÂÆö =============
        function setNaturalPose(vrm) {
            if (!vrm.humanoid) return;
            let v = 1;
            if (!isVRM1) {
                v = -1;
            }
            
            // Â∑¶ËáÇËá™ÁÑ∂‰∏ãÂûÇ
            vrm.humanoid.getNormalizedBoneNode('leftUpperArm').rotation.z = -0.4 * Math.PI * v;

            // Âè≥ËáÇËá™ÁÑ∂‰∏ãÂûÇ
            vrm.humanoid.getNormalizedBoneNode('rightUpperArm').rotation.z = 0.4 * Math.PI * v;
            
            const leftHand = vrm.humanoid.getNormalizedBoneNode('leftHand');
            if (leftHand) {
                leftHand.rotation.z = 0.1 * v; // ÊâãËÖïËá™ÁÑ∂ÂºØÊõ≤
                leftHand.rotation.x = 0.05;
            }
            const rightHand = vrm.humanoid.getNormalizedBoneNode('rightHand');
            if (rightHand) {
                rightHand.rotation.z = -0.1 * v; // ÊâãËÖïËá™ÁÑ∂ÂºØÊõ≤
                rightHand.rotation.x = 0.05;
            }
            
            // Ê∑ªÂä†ÊâãÊåáÁöÑËá™ÁÑ∂ÂºØÊõ≤ÔºàÂ¶ÇÊûúÊ®°ÂûãÊîØÊåÅÔºâ
            const fingerBones = [
                'leftThumbProximal', 'leftThumbIntermediate', 'leftThumbDistal',
                'leftIndexProximal', 'leftIndexIntermediate', 'leftIndexDistal',
                'leftMiddleProximal', 'leftMiddleIntermediate', 'leftMiddleDistal',
                'leftRingProximal', 'leftRingIntermediate', 'leftRingDistal',
                'leftLittleProximal', 'leftLittleIntermediate', 'leftLittleDistal',
                'rightThumbProximal', 'rightThumbIntermediate', 'rightThumbDistal',
                'rightIndexProximal', 'rightIndexIntermediate', 'rightIndexDistal',
                'rightMiddleProximal', 'rightMiddleIntermediate', 'rightMiddleDistal',
                'rightRingProximal', 'rightRingIntermediate', 'rightRingDistal',
                'rightLittleProximal', 'rightLittleIntermediate', 'rightLittleDistal'
            ];

            fingerBones.forEach(boneName => {
                const bone = vrm.humanoid.getNormalizedBoneNode(boneName);
                if (bone) {
                    // Ê†πÊçÆÊâãÊåáÈÉ®‰ΩçËÆæÁΩÆ‰∏çÂêåÁöÑÂºØÊõ≤Â∫¶
                    if (boneName.includes('Thumb')) {
                        // ÊãáÊåáÁ®çÂæÆÂêëÂÜÖ
                        bone.rotation.y = boneName.includes('left') ? 0.35 : -0.35;
                    } else if (boneName.includes('Proximal')) {
                        // ËøëÁ´ØÊåáÈ™®ËΩªÂæÆÂºØÊõ≤
                        bone.rotation.z = boneName.includes('left') ? -0.35 * v : 0.35 * v;
                    } else if (boneName.includes('Intermediate')) {
                        // ‰∏≠Á´ØÊåáÈ™®Á®çÂæÆÂºØÊõ≤
                        bone.rotation.z = boneName.includes('left') ? -0.45 * v : 0.45 * v;
                    } else if (boneName.includes('Distal')) {
                        // ËøúÁ´ØÊåáÈ™®ËΩªÂæÆÂºØÊõ≤
                        bone.rotation.z = boneName.includes('left') ? -0.3 * v : 0.3 * v;
                    }
                }
            });
        }

        // ============= VRM ËºâÂÖ• =============
        async function loadVRM(modelPath) {
            console.log('Loading VRM:', modelPath);
            
            const loader = new GLTFLoader();
            loader.register((parser) => {
                return new VRMLoaderPlugin(parser, {
                    lookAt: { type: 'bone' }
                });
            });

            return new Promise((resolve, reject) => {
                loader.load(
                    modelPath,
                    (gltf) => {
                        const vrm = gltf.userData.vrm;
                        
                        // ÁßªÈô§ËàäÊ®°Âûã
                        if (currentVrm) {
                            scene.remove(currentVrm.scene);
                            VRMUtils.deepDispose(currentVrm.scene);
                        }

                        // ÂÑ™ÂåñÊ®°Âûã
                        VRMUtils.removeUnnecessaryVertices(gltf.scene);
                        VRMUtils.removeUnnecessaryJoints(gltf.scene);

                        // ÊùêË≥™‰øÆÊ≠£
                        vrm.scene.traverse((obj) => {
                            if (obj.material) {
                                if (Array.isArray(obj.material)) {
                                    obj.material.forEach(mat => {
                                        if (mat.transparent) {
                                            mat.depthWrite = false;
                                            mat.alphaTest = 0.5;
                                        }
                                    });
                                } else {
                                    if (obj.material.transparent) {
                                        obj.material.depthWrite = false;
                                        obj.material.alphaTest = 0.5;
                                    }
                                }
                                obj.castShadow = true;
                                obj.receiveShadow = true;
                            }
                        });

                        // ÂïüÁî®Áâ©ÁêÜÊ®°Êì¨
                        if (vrm.springBoneManager) {
                            vrm.springBoneManager.reset();
                        }

                        scene.add(vrm.scene);
                        currentVrm = vrm;
                        currentMixer = new THREE.AnimationMixer(vrm.scene);
                        
                        // Ê£ÄÊµã VRM ÁâàÊú¨
                        isVRM1 = vrm.meta.metaVersion === '1';
                        
                        // ËÆæÁΩÆËá™ÁÑ∂ÂßøÂäø
                        setNaturalPose(vrm);
                        
                        // ÂàùÂßãÂåñÂä®ÁîªÁ≥ªÁªü
                        initAnimationSystem(vrm);

                        console.log('VRM loaded successfully');
                        resolve(vrm);
                    },
                    (progress) => {
                        console.log('Loading progress:', (progress.loaded / progress.total * 100).toFixed(2) + '%');
                    },
                    (error) => {
                        console.error('Error loading VRM:', error);
                        reject(error);
                    }
                );
            });
        }

        // ============= ÂãïÁï´Âæ™Áí∞ =============
        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta();

            // Êõ¥Êñ∞ VRM
            if (currentVrm) {
                currentVrm.update(deltaTime);
            }

            // Êõ¥Êñ∞ Mixer
            if (currentMixer) {
                currentMixer.update(deltaTime);
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // ============= WebSocket ÈÄ£Á∑ö =============
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/vrm`;
            
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('WebSocket connected');
                // statusElement.textContent = 'Â∑≤ÈÄ£Á∑ö';
                // statusElement.className = 'status-connected';
                
                // ÂøÉË∑≥
                setInterval(() => {
                    if (ws.readyState === WebSocket.OPEN) {
                        ws.send('ping');
                    }
                }, 30000);
            };

            ws.onmessage = async (event) => {
                try {
                    // üîß ‰øÆÂæ©ÔºöÊ™¢Êü•ÊòØÂê¶ÁÇ∫Á¥îÊñáÊú¨Ê∂àÊÅØÔºàÂ¶Ç"pong"Ôºâ
                    if (event.data === 'pong') {
                        console.log('üîä [DEBUG] Received pong from server');
                        return;
                    }

                    // ÂòóË©¶Ëß£ÊûêJSONÊ∂àÊÅØ
                    const message = JSON.parse(event.data);
                    console.log('üîä [DEBUG] Received message:', message.type);

                    if (message.type === 'speak') {
                        await handleSpeak(message.data);
                    } else if (message.type === 'switch_model') {
                        await loadVRM(message.data.path);
                    } else if (message.type === 'reset_expression') {
                        resetAllExpressions();
                    } else if (message.type === 'play_animation') {
                        console.log('ÂãïÁï´ÂäüËÉΩÊö´ÊôÇ‰∏çÂèØÁî®');
                    } else if (message.type === 'config_updated') {
                        // üîß Êñ∞Â¢ûÔºöÈÖçÁΩÆÊõ¥Êñ∞ÈÄöÁü•
                        console.log('üîÑ Animation config updated, reloading...');
                        await reloadAnimationConfiguration();
                    }
                } catch (error) {
                    console.error('üîä [ERROR] Error handling WebSocket message:', error);
                    console.error('üîä [ERROR] Raw message data:', event.data);
                }
            };

            ws.onclose = () => {
                console.log('WebSocket disconnected');
                // statusElement.textContent = 'ÈÄ£Á∑ö‰∏≠Êñ∑';
                // statusElement.className = 'status-disconnected';
                
                // ÈáçÈÄ£
                setTimeout(connectWebSocket, 3000);
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
        }

        // ============= TTS Êí≠ÊîæÂíåÂè£ÂûãÂêåÊ≠• =============
        let currentExpression = null;
        let frameCount = 0;

        async function handleSpeak(data) {
            const { chunkId, text, expression, audioData, mimeType } = data;

            console.log('üéµ [QUEUE] Received audio chunk:', text);

            // Â∞ÜÈü≥È¢ëÊï∞ÊçÆÂä†ÂÖ•ÈòüÂàó
            audioQueue.push({
                chunkId,
                text,
                expression,
                audioData,
                mimeType
            });

            console.log(`üéµ [QUEUE] Added to queue. Queue length: ${audioQueue.length}`);

            // Â¶ÇÊûúÂΩìÂâçÊ≤°ÊúâÊí≠ÊîæÔºåÂêØÂä®ÈòüÂàóÊí≠Êîæ
            if (!isPlayingAudio) {
                console.log('üéµ [QUEUE] Not playing, starting queue playback');
                await playNextInQueue();
            } else {
                console.log('üéµ [QUEUE] Already playing, audio will play after current one finishes');
            }
        }

        // Êí≠ÊîæÈòüÂàó‰∏≠ÁöÑ‰∏ã‰∏Ä‰∏™Èü≥È¢ë
        async function playNextInQueue() {
            // Â¶ÇÊûúÈòüÂàó‰∏∫Á©∫ÔºåÈáçÁΩÆÊí≠ÊîæÁä∂ÊÄÅ
            if (audioQueue.length === 0) {
                console.log('üéµ [QUEUE] Queue empty, stopping playback');
                isPlayingAudio = false;
                return;
            }

            // Ê†áËÆ∞Ê≠£Âú®Êí≠Êîæ
            isPlayingAudio = true;

            // ‰ªéÈòüÂàó‰∏≠ÂèñÂá∫Á¨¨‰∏Ä‰∏™Èü≥È¢ëÊï∞ÊçÆ
            const data = audioQueue.shift();
            console.log(`üéµ [QUEUE] Playing audio: "${data.text}" (${audioQueue.length} remaining in queue)`);

            const { text, expression, audioData, mimeType } = data;

            // ÊòæÁ§∫Â≠óÂπï
            showSubtitle(text);

            // ÈáçÁΩÆ‰πãÂâçÁöÑË°®ÊÉÖÔºåÈÅøÂÖçÂÜ≤Á™Å
            if (currentVrm && currentVrm.expressionManager) {
                currentVrm.expressionManager.setValue('aa', 0);
                currentVrm.expressionManager.setValue('ih', 0);

                // ÈáçÁΩÆÂÖ∂‰ªñË°®ÊÉÖ
                ['happy', 'angry', 'sad', 'surprised', 'relaxed'].forEach(exp => {
                    currentVrm.expressionManager.setValue(exp, 0);
                });
            }

            // ËÆæÂÆöÊñ∞ÁöÑË°®ÊÉÖ
            currentExpression = null;
            if (expression && currentVrm) {
                const validExpressions = ['happy', 'angry', 'sad', 'neutral', 'surprised', 'relaxed'];
                if (validExpressions.includes(expression)) {
                    currentExpression = expression;

                    // ÈÖçÁΩÆË°®ÊÉÖÂíåÂè£ÂûãÁöÑÂÜ≤Á™ÅÂ§ÑÁêÜ
                    if (currentVrm.expressionManager) {
                        // ËÆæÁΩÆÂè£ÂûãË°®ÊÉÖ‰∏∫ÂèØË¶ÜÁõñ
                        currentVrm.expressionManager.mouthExpressionNames = ['aa', 'ih'];

                        // ‰∏∫ÁâπÂÆöË°®ÊÉÖËÆæÁΩÆÂè£ÂûãË¶ÜÁõñÂ±ûÊÄß
                        const mouthOverrideExpressions = ['happy', 'surprised'];
                        mouthOverrideExpressions.forEach(expName => {
                            const exp = currentVrm.expressionManager.getExpression?.(expName);
                            if (exp) {
                                exp.overrideMouth = 'block';
                            }
                        });

                        currentVrm.expressionManager.setValue(expression, 1.0);
                    }
                }
            }

            // Êí≠ÊîæÈü≥È¢ë
            if (audioData) {
                await playAudioWithLipSync(audioData, mimeType);
            }

            // Êí≠ÊîæÂÆåÊàêÂêéÔºåÁªßÁª≠Êí≠ÊîæÈòüÂàó‰∏≠ÁöÑ‰∏ã‰∏Ä‰∏™
            console.log('üéµ [QUEUE] Audio finished, checking for next in queue');
            await playNextInQueue();
        }

        async function playAudioWithLipSync(audioBase64, mimeType) {
            return new Promise(async (resolve, reject) => {
                try {
                    console.log('üîä [DEBUG] Starting audio playback...');
                    console.log('üîä [DEBUG] Audio data length:', audioBase64.length);
                    console.log('üîä [DEBUG] MIME type:', mimeType);

                // ÂàùÂßãÂåñ AudioContext
                if (!audioContext) {
                    console.log('üîä [DEBUG] Creating new AudioContext...');
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                // Ê™¢Êü• AudioContext ÁãÄÊÖã
                if (audioContext.state === 'suspended') {
                    console.log('üîä [DEBUG] AudioContext was suspended, resuming...');
                    await audioContext.resume();
                }

                // ÂÅúÊ≠¢Áï∂ÂâçÈü≥Ë®ä
                if (currentAudio) {
                    console.log('üîä [DEBUG] Stopping previous audio...');
                    currentAudio.pause();
                    currentAudio.currentTime = 0;
                    currentAudio = null;
                }

                // Ëß£Á¢º base64
                console.log('üîä [DEBUG] Decoding base64 audio data...');
                const audioBytes = Uint8Array.from(atob(audioBase64), c => c.charCodeAt(0));
                const audioBlob = new Blob([audioBytes], { type: mimeType });
                const audioUrl = URL.createObjectURL(audioBlob);
                console.log('üîä [DEBUG] Created audio URL:', audioUrl);

                // ÂâµÂª∫Èü≥Ë®äÂÖÉÁ¥†
                const audio = new Audio(audioUrl);
                currentAudio = audio;

                // Ë®≠ÁΩÆÈü≥Ë®äÂ±¨ÊÄß
                audio.volume = 1.0;
                audio.preload = 'auto';

                // üîß ‰øÆÂæ©ÔºöÊ™¢Êü•AudioContextÊòØÂê¶Â∑≤Á∂ìÈÄ£Êé•ÈÅé
                let source, analyser;
                try {
                    console.log('üîä [DEBUG] Creating MediaElementSource...');
                    source = audioContext.createMediaElementSource(audio);
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 256;
                    analyser.smoothingTimeConstant = 0.8;

                    source.connect(analyser);
                    analyser.connect(audioContext.destination);
                    console.log('üîä [DEBUG] Audio pipeline connected successfully');
                } catch (sourceError) {
                    console.error('üîä [ERROR] Failed to create audio source:', sourceError);
                    // Â¶ÇÊûúAudioContextÈÄ£Êé•Â§±ÊïóÔºåÁõ¥Êé•Êí≠ÊîæÈü≥È†ªÔºàÁÑ°Âè£ÂûãÂêåÊ≠•Ôºâ
                    analyser = null;
                    console.log('üîä [DEBUG] Falling back to direct audio playback');
                }

                const bufferLength = analyser ? analyser.frequencyBinCount : 0;
                const dataArray = analyser ? new Uint8Array(bufferLength) : null;

                frameCount = 0;

                // Âè£ÂûãÂêåÊ≠•ÂãïÁï´
                const animateLipSync = () => {
                    if (audio.paused || audio.ended) {
                        console.log('üîä [DEBUG] Audio ended, resetting expressions...');
                        // Êí≠ÊîæÁµêÊùüÔºåÈáçÁΩÆÂè£Âûã‰ΩÜ‰øùÊåÅÂÖ∂‰ªñË°®ÊÉÖ
                        if (currentVrm && currentVrm.expressionManager) {
                            currentVrm.expressionManager.setValue('aa', 0);
                            currentVrm.expressionManager.setValue('ih', 0);
                            
                            // ‰øùÊåÅÁï∂ÂâçË°®ÊÉÖ‰∏ÄÊÆµÊôÇÈñì
                            setTimeout(() => {
                                if (currentVrm && currentVrm.expressionManager) {
                                    ['happy', 'angry', 'sad', 'surprised', 'relaxed'].forEach(exp => {
                                        currentVrm.expressionManager.setValue(exp, 0);
                                    });
                                }
                            }, 2000);
                        }
                        return;
                    }

                    frameCount++;
                    
                    // üîß ‰øÆÂæ©ÔºöÊ™¢Êü•analyserÊòØÂê¶Â≠òÂú®
                    let intensity = 0;
                    if (analyser && dataArray) {
                        try {
                            analyser.getByteFrequencyData(dataArray);
                            
                            // Ë®àÁÆóÈü≥ÈáèÔºàÂÉÖ‰ΩøÁî®‰∏≠‰ΩéÈ†ªÔºâ
                            const relevantData = dataArray.slice(0, Math.floor(bufferLength / 2));
                            const sum = relevantData.reduce((a, b) => a + b, 0);
                            const average = sum / relevantData.length;
                            intensity = Math.min(average / 128, 1.0);
                        } catch (analyserError) {
                            console.error('üîä [ERROR] Audio analysis failed:', analyserError);
                            intensity = 0;
                        }
                    } else {
                        // Â¶ÇÊûúÊ≤íÊúâanalyserÔºå‰ΩøÁî®Âü∫Êú¨ÁöÑÊôÇÈñìÈ©ÖÂãïÂè£ÂûãÂãïÁï´
                        intensity = Math.sin(frameCount * 0.2) * 0.3 + 0.3; // Âü∫Êú¨Âè£ÂûãÂãïÁï´
                    }

                    // È©ÖÂãïÂè£Âûã - Â§ßÂπÖÈôç‰ΩéÂº∑Â∫¶
                    if (currentVrm && currentVrm.expressionManager && intensity > 0.3) {
                        let maxMouthOpen = 0.4; // Â§ßÂπÖÈôç‰ΩéÊúÄÂ§ßÂºµÂò¥
                        
                        // Ê†πÊìöÁï∂ÂâçË°®ÊÉÖË™øÊï¥Âè£ÂûãÂº∑Â∫¶
                        if (currentExpression) {
                            if (['happy', 'surprised'].includes(currentExpression)) {
                                maxMouthOpen = 0.3; // ÈñãÂøÉÂíåÈ©öË®ùË°®ÊÉÖÊôÇÈÄ≤‰∏ÄÊ≠•Èôç‰Ωé
                            } else if (['angry', 'sad'].includes(currentExpression)) {
                                maxMouthOpen = 0.12;
                            }
                            
                            // ‰øùÊåÅÁï∂ÂâçË°®ÊÉÖ
                            currentVrm.expressionManager.setValue(currentExpression, 1.0);
                        }
                        
                        const mouthOpen = Math.min(intensity * 0.3, maxMouthOpen); // Â§ßÂπÖÈôç‰ΩéÂº∑Â∫¶‰øÇÊï∏
                        currentVrm.expressionManager.setValue('aa', mouthOpen);
                        
                        // Ê∑ªÂä†Á¥∞ÂæÆÁöÑÂè£ÂûãËÆäÂåñ
                        const variation = Math.sin(frameCount * 0.1) * 0.02;
                        const ihValue = Math.min(Math.max(0, mouthOpen * 0.2 + variation), maxMouthOpen * 0.5);
                        currentVrm.expressionManager.setValue('ih', ihValue);
                    } else if (currentVrm && currentVrm.expressionManager) {
                        // Âπ≥ÊªëÈñâÂò¥
                        const currentAA = currentVrm.expressionManager.getValue?.('aa') || 0;
                        const currentIH = currentVrm.expressionManager.getValue?.('ih') || 0;
                        currentVrm.expressionManager.setValue('aa', Math.max(0, currentAA * 0.7 - 0.01));
                        currentVrm.expressionManager.setValue('ih', Math.max(0, currentIH * 0.6 - 0.005));
                        
                        // ‰øùÊåÅÂÖ∂‰ªñË°®ÊÉÖ
                        if (currentExpression) {
                            currentVrm.expressionManager.setValue(currentExpression, 1.0);
                        }
                    }

                    requestAnimationFrame(animateLipSync);
                };

                // üîß ‰øÆÂæ©ÔºöÊ∑ªÂä†audio‰∫ã‰ª∂Áõ£ËÅΩÂô®
                audio.addEventListener('loadstart', () => console.log('üîä [DEBUG] Audio loading started...'));
                audio.addEventListener('loadeddata', () => console.log('üîä [DEBUG] Audio data loaded'));
                audio.addEventListener('canplay', () => console.log('üîä [DEBUG] Audio can start playing'));
                audio.addEventListener('play', () => console.log('üîä [DEBUG] Audio playback started'));
                audio.addEventListener('error', (e) => console.error('üîä [ERROR] Audio error:', e));

                // ÁµêÊùüÊôÇÈö±ËóèÂ≠óÂπïÂπ∂ resolve Promise
                audio.onended = () => {
                    console.log('üéµ [QUEUE] Audio playback completed');
                    hideSubtitle();
                    URL.revokeObjectURL(audioUrl);
                    currentAudio = null;
                    resolve(); // ÈÄöÁü•Êí≠ÊîæÂÆåÊàê
                };

                // Êí≠ÊîæÈîôËØØÊó∂‰πüË¶Å resolveÔºåÁ°Æ‰øùÈòüÂàóÁªßÁª≠
                audio.onerror = (error) => {
                    console.error('üîä [ERROR] Audio playback error:', error);
                    hideSubtitle();
                    URL.revokeObjectURL(audioUrl);
                    currentAudio = null;
                    resolve(); // Âç≥‰ΩøÂá∫Èîô‰πüÁªßÁª≠ÈòüÂàó
                };

                // Êí≠ÊîæÈü≥È†ª
                console.log('üîä [DEBUG] Starting audio playback...');
                const playPromise = audio.play();
                if (playPromise !== undefined) {
                    playPromise
                        .then(() => {
                            console.log('üîä [DEBUG] Audio playback started successfully');
                            animateLipSync();
                        })
                        .catch(error => {
                            console.error('üîä [ERROR] Audio playback failed:', error);
                            // Âç≥‰ΩøÊí≠ÊîæÂ§±ÊïóÔºå‰πüË¶ÅÈö±ËóèÂ≠óÂπïÂπ∂ resolve
                            hideSubtitle();
                            resolve();
                        });
                } else {
                    // ËÄÅÁâàÊú¨ÁÄèË¶ΩÂô®
                    animateLipSync();
                }

                } catch (error) {
                    console.error('Error playing audio:', error);
                    hideSubtitle();
                    reject(error);
                }
            });
        }

        // ÈáçÁΩÆÊâÄÊúâË°®ÊÉÖÁöÑÂáΩÊï∏
        function resetAllExpressions() {
            console.log('üîÑ [RESET] Resetting all expressions and clearing audio queue');

            // 1. Ê∏ÖÁ©∫Èü≥È†ªÊí≠ÊîæÈöäÂàó
            audioQueue = [];
            isPlayingAudio = false;
            console.log('üéµ [QUEUE] Audio queue cleared');

            // 2. ÂÅúÊ≠¢Áï∂ÂâçÈü≥Ë®ä
            if (currentAudio) {
                console.log('üîä [AUDIO] Stopping current audio');
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio = null;
            }

            // 3. Èö±ËóèÂ≠óÂπï
            hideSubtitle();

            // 4. ÈáçÁΩÆË°®ÊÉÖÁÆ°ÁêÜÂô®
            if (currentVrm && currentVrm.expressionManager) {
                // ÈáçÁΩÆÊâÄÊúâË°®ÊÉÖÂÄº
                const allExpressions = ['aa', 'ih', 'happy', 'angry', 'sad', 'neutral', 'surprised', 'relaxed', 'blink'];
                allExpressions.forEach(exp => {
                    currentVrm.expressionManager.setValue(exp, 0);
                });

                currentExpression = null;
                frameCount = 0;

                console.log('‚úÖ [RESET] Expression reset complete');
                return true;
            }

            console.log('‚ö†Ô∏è [RESET] VRM not ready, queue cleared anyway');
            return false;
        }

        // ============= ÂÆåÊï¥ÁöÑ IdleAnimationManager È°û =============
        class IdleAnimationManager {
            constructor(vrm, mixer) {
                this.vrm = vrm;
                this.mixer = mixer;
                this.currentIdleAction = null;
                this.defaultPoseAction = null;
                this.proceduralIdleAction = null;
                this.isTransitioning = false;
                this.animationQueue = [];
                this.currentIndex = 0;
                this.transitionDuration = 0.8;
                this.pauseBetweenAnimations = 1.5;
                this.idleWeight = 1.0;
                this.isActive = false;
                this.currentMode = 'none';
                
                // ÂâµÂª∫ÈªòË™çÂßøÂã¢Âãï‰Ωú
                this.createDefaultPoseAction();
                // ÂâµÂª∫Á®ãÂ∫èÂåñÈñíÁΩÆÂãïÁï´
                this.createProceduralIdleAction();
                
                console.log('IdleAnimationManager initialized');
            }
            
            // ÂâµÂª∫ÈªòË™çÂßøÂã¢Âãï‰Ωú
            createDefaultPoseAction() {
                try {
                    const defaultPoseClip = this.createDefaultPoseClip();
                    this.defaultPoseAction = this.mixer.clipAction(defaultPoseClip);
                    this.defaultPoseAction.setLoop(THREE.LoopOnce);
                    this.defaultPoseAction.clampWhenFinished = true;
                    this.defaultPoseAction.setEffectiveWeight(0);
                    console.log('Default pose action created');
                } catch (error) {
                    console.error('Error creating default pose action:', error);
                }
            }
            
            // ÂâµÂª∫Á®ãÂ∫èÂåñÈñíÁΩÆÂãïÁï´
            createProceduralIdleAction() {
                try {
                    console.log('Creating procedural idle action...');
                    const idleClip = createIdleClip(this.vrm);
                    if (!idleClip) {
                        console.error('Failed to create idle clip');
                        return;
                    }
                    
                    this.proceduralIdleAction = this.mixer.clipAction(idleClip);
                    this.proceduralIdleAction.setLoop(THREE.LoopRepeat);
                    this.proceduralIdleAction.setEffectiveWeight(0);
                    
                    console.log('Procedural idle action created successfully');
                } catch (error) {
                    console.error('Error creating procedural idle action:', error);
                }
            }
            
            // ÂâµÂª∫ÈªòË™çÂßøÂã¢clip
            createDefaultPoseClip() {
                const tracks = [];
                const duration = 1.0;
                const fps = 30;
                const frameCount = duration * fps;
                
                const times = [];
                for (let i = 0; i <= frameCount; i++) {
                    times.push(i / fps);
                }
                
                const bonesToReset = [
                    'hips', 'spine', 'chest', 'upperChest', 'neck', 'head',
                    'leftShoulder', 'leftUpperArm', 'leftLowerArm', 'leftHand',
                    'rightShoulder', 'rightUpperArm', 'rightLowerArm', 'rightHand',
                    'leftUpperLeg', 'leftLowerLeg', 'leftFoot', 'leftToes',
                    'rightUpperLeg', 'rightLowerLeg', 'rightFoot', 'rightToes'
                ];
                
                bonesToReset.forEach(boneName => {
                    const bone = this.vrm.humanoid?.getNormalizedBoneNode(boneName);
                    if (!bone) return;
                    
                    const naturalRotation = this.getNaturalRotation(boneName);
                    const values = [];
                    
                    times.forEach((time, index) => {
                        if (index === 0) {
                            values.push(...bone.quaternion.toArray());
                        } else {
                            const progress = time / duration;
                            const easedProgress = this.easeInOutCubic(progress);
                            
                            const currentQuat = new THREE.Quaternion().fromArray(
                                values.slice((index - 1) * 4, index * 4)
                            );
                            
                            const interpolatedQuat = currentQuat.clone().slerp(naturalRotation, easedProgress);
                            values.push(...interpolatedQuat.toArray());
                        }
                    });
                    
                    const track = new THREE.QuaternionKeyframeTrack(
                        bone.name + '.quaternion',
                        times,
                        values
                    );
                    
                    tracks.push(track);
                });
                
                return new THREE.AnimationClip('defaultPose', duration, tracks);
            }
            
            easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }
            
            getNaturalRotation(boneName) {
                const euler = new THREE.Euler(0, 0, 0);
                const v = isVRM1 ? 1 : -1;
                
                switch (boneName) {
                    case 'leftUpperArm':
                        euler.set(0, 0, -0.4 * Math.PI * v);
                        break;
                    case 'rightUpperArm':
                        euler.set(0, 0, 0.4 * Math.PI * v);
                        break;
                    case 'leftHand':
                        euler.set(0.05, 0, 0.1 * v);
                        break;
                    case 'rightHand':
                        euler.set(0.05, 0, -0.1 * v);
                        break;
                    default:
                        euler.set(0, 0, 0);
                        break;
                }
                
                const quaternion = new THREE.Quaternion();
                quaternion.setFromEuler(euler);
                return quaternion;
            }
            
            setAnimationQueue(animations) {
                this.animationQueue = [...animations];
                this.currentIndex = 0;
                console.log(`Idle animation queue set with ${animations.length} animations`);
            }
            
            startIdleLoop() {
                if (this.animationQueue.length === 0) {
                    console.warn('No idle animations available, switching to procedural mode');
                    this.switchToProceduralMode();
                    return;
                }
                
                console.log('Starting VRMA idle animation loop');
                this.currentMode = 'vrma';
                this.isActive = true;
                this.playNextVRMAAnimation();
            }
            
            playNextVRMAAnimation() {
                console.log(`üéÆ [DEBUG] playNextVRMAAnimation called - isActive: ${this.isActive}, mode: ${this.currentMode}, queueLength: ${this.animationQueue.length}`);
                
                if (!this.isActive || this.currentMode !== 'vrma' || this.animationQueue.length === 0) {
                    console.log(`üö´ [DEBUG] Skipping playback - conditions not met`);
                    return;
                }
                
                if (this.isTransitioning) {
                    console.log(`‚è≥ [DEBUG] Still transitioning, retrying in 100ms`);
                    setTimeout(() => this.playNextVRMAAnimation(), 100);
                    return;
                }
                
                const animation = this.animationQueue[this.currentIndex];
                console.log(`üé≠ [DEBUG] Playing VRMA animation: ${animation.name} (${this.currentIndex + 1}/${this.animationQueue.length})`);
                console.log(`üìä [DEBUG] Animation details:`, {
                    name: animation.name,
                    hasAnimation: !!animation.animation,
                    file: animation.file
                });
                
                this.playVRMAAnimation(animation);
                
                // Èö®Ê©üÈÅ∏Êìá‰∏ã‰∏ÄÂÄãÂãïÁï´ÔºàÈÅøÂÖçÈáçË§áÔºâ
                const previousIndex = this.currentIndex;
                const length = this.animationQueue.length;

                if (length < 2) {
                    this.currentIndex = 0;
                } else {
                    let newIndex;
                    do {
                        newIndex = Math.floor(Math.random() * length);
                    } while (newIndex === previousIndex);
                    this.currentIndex = newIndex;
                }
                
                console.log(`üîÑ [DEBUG] Next animation index set to: ${this.currentIndex}`);
            }
            
            playVRMAAnimation(animationData) {
                if (!animationData || !animationData.animation) {
                    console.error('Invalid VRMA animation data');
                    this.scheduleNextVRMAAnimation();
                    return;
                }
                
                try {
                    // ÈúÄË¶ÅÂãïÊÖãÂåØÂÖ• createVRMAnimationClip
                    import('@pixiv/three-vrm-animation').then(({ createVRMAnimationClip }) => {
                        const clip = createVRMAnimationClip(animationData.animation, this.vrm);
                        if (!clip) {
                            console.error('Failed to create VRMA animation clip');
                            this.scheduleNextVRMAAnimation();
                            return;
                        }
                        
                        this.currentIdleAction = this.mixer.clipAction(clip);
                        this.currentIdleAction.setLoop(THREE.LoopOnce);
                        this.currentIdleAction.clampWhenFinished = true;
                        this.currentIdleAction.fadeIn(1.0);
                        this.currentIdleAction.play();
                        
                        const onFinished = (event) => {
                            if (event.action === this.currentIdleAction) {
                                console.log(`VRMA animation ${animationData.name} finished`);
                                this.onVRMAAnimationFinished();
                                this.mixer.removeEventListener('finished', onFinished);
                            }
                        };
                        
                        this.mixer.addEventListener('finished', onFinished);
                    }).catch(error => {
                        console.error('Failed to load VRM animation library:', error);
                        this.scheduleNextVRMAAnimation();
                    });
                    
                } catch (error) {
                    console.error(`Error playing VRMA animation ${animationData.name}:`, error);
                    this.scheduleNextVRMAAnimation();
                }
            }
            
            onVRMAAnimationFinished() {
                if (this.currentMode !== 'vrma' || !this.isActive) {
                    return;
                }
                
                console.log('VRMA animation finished, transitioning to default pose');
                this.isTransitioning = true;
                
                if (this.currentIdleAction) {
                    this.currentIdleAction.fadeOut(1.0);
                }
                
                if (this.defaultPoseAction) {
                    this.defaultPoseAction.reset();
                    this.defaultPoseAction.setEffectiveWeight(0);
                    this.defaultPoseAction.play();
                    this.defaultPoseAction.fadeIn(this.transitionDuration * 0.5);
                    
                    setTimeout(() => {
                        if (this.defaultPoseAction) {
                            this.defaultPoseAction.setEffectiveWeight(this.idleWeight);
                        }
                    }, this.transitionDuration * 250);
                }
                
                setTimeout(() => {
                    if (this.currentMode !== 'vrma' || !this.isActive) {
                        this.isTransitioning = false;
                        return;
                    }
                    
                    setTimeout(() => {
                        if (this.currentMode !== 'vrma' || !this.isActive) {
                            this.isTransitioning = false;
                            return;
                        }
                        
                        if (this.defaultPoseAction) {
                            this.defaultPoseAction.fadeOut(this.transitionDuration * 0.3);
                        }
                        
                        this.isTransitioning = false;
                        
                        setTimeout(() => {
                            if (this.currentMode === 'vrma' && this.isActive) {
                                this.playNextVRMAAnimation();
                            }
                        }, 300);
                        
                    }, this.pauseBetweenAnimations * 1000);
                    
                }, this.transitionDuration * 600);
            }
            
            scheduleNextVRMAAnimation() {
                if (this.currentMode === 'vrma' && this.isActive) {
                    setTimeout(() => {
                        this.playNextVRMAAnimation();
                    }, this.pauseBetweenAnimations * 1000);
                }
            }
            
            switchToVRMAMode() {
                console.log('Switching to VRMA idle animations');
                this.stopProceduralAnimations();
                
                if (this.animationQueue.length > 0) {
                    this.startIdleLoop();
                } else {
                    console.warn('No VRMA animations available, falling back to procedural');
                    this.switchToProceduralMode();
                }
            }
            
            switchToProceduralMode() {
                console.log('Switching to procedural idle animation');
                this.stopVRMAAnimations();
                
                this.currentMode = 'procedural';
                this.isActive = true;
                
                if (this.proceduralIdleAction) {
                    if (this.proceduralIdleAction.isRunning()) {
                        this.proceduralIdleAction.setEffectiveWeight(this.idleWeight);
                    } else {
                        this.proceduralIdleAction.reset();
                        this.proceduralIdleAction.setEffectiveWeight(this.idleWeight);
                        this.proceduralIdleAction.play();
                    }
                }
            }
            
            stopVRMAAnimations() {
                console.log('Stopping VRMA animations only');
                const fadeTime = 0.5;
                
                if (this.currentIdleAction && this.currentIdleAction.isRunning()) {
                    this.currentIdleAction.fadeOut(fadeTime);
                    setTimeout(() => {
                        if (this.currentIdleAction) {
                            this.currentIdleAction.stop();
                            this.currentIdleAction = null;
                        }
                    }, fadeTime * 1000);
                }
                
                if (this.defaultPoseAction && this.defaultPoseAction.isRunning()) {
                    this.defaultPoseAction.fadeOut(fadeTime);
                }
            }
            
            stopProceduralAnimations() {
                console.log('Stopping procedural animations only');
                const fadeTime = 0.5;
                
                if (this.proceduralIdleAction && this.proceduralIdleAction.isRunning()) {
                    this.proceduralIdleAction.fadeOut(fadeTime);
                    setTimeout(() => {
                        if (this.proceduralIdleAction) {
                            this.proceduralIdleAction.stop();
                        }
                    }, fadeTime * 1000);
                }
            }
            
            stopAllAnimations() {
                console.log('Stopping all idle animations');
                this.isActive = false;
                this.isTransitioning = false;
                
                const fadeTime = 0.5;
                
                if (this.currentIdleAction && this.currentIdleAction.isRunning()) {
                    this.currentIdleAction.fadeOut(fadeTime);
                    setTimeout(() => {
                        if (this.currentIdleAction) {
                            this.currentIdleAction.stop();
                            this.currentIdleAction = null;
                        }
                    }, fadeTime * 1000);
                }
                
                if (this.proceduralIdleAction && this.proceduralIdleAction.isRunning()) {
                    this.proceduralIdleAction.fadeOut(fadeTime);
                    setTimeout(() => {
                        if (this.proceduralIdleAction) {
                            this.proceduralIdleAction.stop();
                        }
                    }, fadeTime * 1000);
                }
                
                if (this.defaultPoseAction && this.defaultPoseAction.isRunning()) {
                    this.defaultPoseAction.fadeOut(fadeTime);
                    setTimeout(() => {
                        if (this.defaultPoseAction) {
                            this.defaultPoseAction.stop();
                        }
                    }, fadeTime * 1000);
                }
                
                this.currentMode = 'none';
            }
        }

        // ============= ÈÖçÁΩÆÈáçËºâÂáΩÊï∏ =============
        async function reloadAnimationConfiguration() {
            if (!idleAnimationManager) {
                console.warn('Animation manager not available for reload');
                return;
            }

            try {
                console.log('üîÑ Reloading animation configuration...');
                
                // ÈáçÊñ∞ËºâÂÖ•ÂãïÁï´ÈÖçÁΩÆ
                const animationFiles = await getAnimationFiles();
                
                // ÂÅúÊ≠¢Áï∂ÂâçÂãïÁï´
                idleAnimationManager.stopAllAnimations();
                
                // Ê∏ÖÁ©∫Áï∂ÂâçÂãïÁï´Êï∏Êìö
                idleAnimations = [];
                isLoadingAnimations = false;
                
                // ÈáçÊñ∞ËºâÂÖ•ÂãïÁï´
                if (animationFiles.length > 0) {
                    console.log('üìÅ Loading new animation configuration...');
                    await loadIdleAnimations();
                    
                    if (idleAnimations.length > 0) {
                        idleAnimationManager.setAnimationQueue(idleAnimations);
                        idleAnimationManager.switchToVRMAMode();
                        console.log('‚úÖ Animation configuration reloaded successfully!');
                    } else {
                        console.warn('‚ö†Ô∏è  No valid animations loaded, switching to procedural');
                        idleAnimationManager.switchToProceduralMode();
                    }
                } else {
                    console.log('‚ÑπÔ∏è  No animations selected, switching to procedural mode');
                    idleAnimationManager.switchToProceduralMode();
                }
                
            } catch (error) {
                console.error('‚ùå Failed to reload animation configuration:', error);
                // Â§±ÊïóÊôÇÂõûÂà∞Á®ãÂ∫èÂåñÂãïÁï´
                if (idleAnimationManager) {
                    idleAnimationManager.switchToProceduralMode();
                }
            }
        }

        // ============= ÂãïÁï´ËºâÂÖ•ÂíåÁÆ°ÁêÜÂáΩÊï∏ =============
        async function getAnimationFiles() {
            try {
                console.log('üîÑ [DEBUG] Fetching animation configuration from server...');
                const response = await fetch('/api/vrm/config');
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                const config = data.VRMConfig;
                
                if (!config) {
                    throw new Error('Invalid config response: missing VRMConfig');
                }
                
                // Áç≤ÂèñÈÅ∏‰∏≠ÁöÑÂãïÁï´ ID
                const selectedMotionIds = config.selectedMotionIds || [];
                console.log('‚úÖ [DEBUG] Selected motion IDs from server:', selectedMotionIds);
                console.log('üìä [DEBUG] Config details:', {
                    selectedCount: selectedMotionIds.length,
                    defaultMotionsCount: config.defaultMotions.length,
                    userMotionsCount: config.userMotions.length
                });
                
                // Â¶ÇÊûúÊ≤íÊúâÈÅ∏‰∏≠ÁöÑÂãïÁï´ÔºåËøîÂõûÁ©∫Êï∏ÁµÑÔºàÂ∞á‰ΩøÁî®Á®ãÂ∫èÂåñÂãïÁï´Ôºâ
                if (selectedMotionIds.length === 0) {
                    console.log('‚ÑπÔ∏è  [DEBUG] No animations selected, will use procedural animations only');
                    return [];
                }
                
                // Áç≤ÂèñÊâÄÊúâÂèØÁî®ÂãïÁï´
                const allMotions = [...config.defaultMotions, ...config.userMotions];
                console.log('üìÅ [DEBUG] Available motions:', allMotions.map(m => `${m.id}:${m.name}`));
                
                // Ê†πÊìöÈÅ∏‰∏≠ÁöÑ ID ÁØ©ÈÅ∏ÂãïÁï´‰∏¶ÊßãÈÄ†ÂÆåÊï¥ URL
                const selectedAnimations = selectedMotionIds
                    .map(id => {
                        const motion = allMotions.find(m => m.id === id);
                        if (motion) {
                            const url = `${window.location.protocol}//${window.location.host}${motion.path}`;
                            console.log(`‚úÖ [DEBUG] Found motion: ${id} -> ${url}`);
                            return url;
                        }
                        console.warn(`‚ö†Ô∏è  [DEBUG] Animation not found: ${id}`);
                        return null;
                    })
                    .filter(url => url !== null);
                
                console.log(`üé≠ [DEBUG] Final selected animations (${selectedAnimations.length}):`, selectedAnimations);
                return selectedAnimations;
                
            } catch (error) {
                console.error('‚ùå [DEBUG] Error getting animation files from config:', error);
                console.warn('üîô [DEBUG] Falling back to procedural animations only (no VRMA files)');
                
                return [];
            }
        }

        async function loadVRMAAnimation(url) {
            return new Promise((resolve, reject) => {
                const loader = new GLTFLoader();
                
                // üîß Ê≠£Á¢∫Ë®ªÂÜä VRMAnimationLoaderPlugin
                loader.register((parser) => {
                    return new VRMAnimationLoaderPlugin(parser);
                });
                
                loader.load(
                    url,
                    (gltf) => {
                        // ‚úÖ ÁúüÂØ¶ËºâÂÖ• VRM ÂãïÁï´Êï∏Êìö
                        const vrmAnimations = gltf.userData.vrmAnimations;
                        if (vrmAnimations && vrmAnimations.length > 0) {
                            console.log(`Successfully loaded animation: ${url.split('/').pop()}`);
                            resolve(vrmAnimations[0]); // ËøîÂõûÁ¨¨‰∏ÄÂÄãÂãïÁï´
                        } else {
                            console.warn(`No VRM animation found in: ${url}`);
                            resolve(null); // Ê≤íÊúâÂãïÁï´ÊôÇËøîÂõû null
                        }
                    },
                    (progress) => {
                        console.log(`Loading animation ${url.split('/').pop()}...`, 
                                  Math.round((progress.loaded / progress.total) * 100), '%');
                    },
                    (error) => {
                        console.error(`Failed to load animation: ${url}`, error);
                        // üîß Â§±ÊïóÊôÇËøîÂõû null ËÄå‰∏çÊòØ rejectÔºå‰øùË≠âÂÖ∂‰ªñÂãïÁï´ËÉΩÁπºÁ∫åËºâÂÖ•
                        resolve(null);
                    }
                );
            });
        }

        async function loadIdleAnimations() {
            if (isLoadingAnimations) return;
            isLoadingAnimations = true;
            
            console.log('Loading idle animations...');
            
            try {
                const animationFiles = await getAnimationFiles();
                idleAnimations = [];
                
                for (const file of animationFiles) {
                    try {
                        const animation = await loadVRMAAnimation(file);
                        if (animation) { // Âè™Ê∑ªÂä†ÊàêÂäüËºâÂÖ•ÁöÑÂãïÁï´
                            idleAnimations.push({
                                animation: animation,
                                file: file,
                                name: file.split('/').pop().replace('.vrma', '')
                            });
                            console.log(`Loaded animation: ${file}`);
                        }
                    } catch (error) {
                        console.warn(`Failed to load animation: ${file}`, error);
                    }
                }
                
                console.log(`Successfully loaded ${idleAnimations.length} idle animations`);
                
            } catch (error) {
                console.error('Error loading idle animations:', error);
            } finally {
                isLoadingAnimations = false;
            }
        }

        async function startIdleAnimationLoop() {
            if (!idleAnimationManager) {
                console.error('Idle animation manager not available');
                return;
            }
            
            console.log(`Starting idle animation with mode: ${useVRMAIdleAnimations ? 'VRMA' : 'Procedural'}`);
            
            if (useVRMAIdleAnimations) {
                if (idleAnimations.length === 0) {
                    console.log('Loading VRMA animations...');
                    await loadIdleAnimations();
                }
                
                if (idleAnimations.length > 0) {
                    idleAnimationManager.setAnimationQueue(idleAnimations);
                    idleAnimationManager.switchToVRMAMode();
                } else {
                    console.warn('No VRMA animations available, falling back to procedural');
                    idleAnimationManager.switchToProceduralMode();
                }
            } else {
                idleAnimationManager.switchToProceduralMode();
            }
        }

        async function toggleIdleAnimationMode() {
            if (isIdleAnimationModeChanging || !idleAnimationManager) {
                return;
            }
            
            isIdleAnimationModeChanging = true;
            useVRMAIdleAnimations = !useVRMAIdleAnimations;
            
            console.log(`Switching idle animation mode to: ${useVRMAIdleAnimations ? 'VRMA' : 'Procedural'}`);
            
            try {
                if (useVRMAIdleAnimations) {
                    if (idleAnimations.length === 0) {
                        await loadIdleAnimations();
                    }
                    
                    if (idleAnimationManager) {
                        idleAnimationManager.setAnimationQueue(idleAnimations);
                        idleAnimationManager.switchToVRMAMode();
                    }
                } else {
                    if (idleAnimationManager) {
                        idleAnimationManager.switchToProceduralMode();
                    }
                }
            } catch (error) {
                console.error('Error switching idle animation mode:', error);
                useVRMAIdleAnimations = !useVRMAIdleAnimations;
            } finally {
                isIdleAnimationModeChanging = false;
            }
        }

        // ============= ÂãïÁï´Á≥ªÁµ±ÂàùÂßãÂåñ =============
        function initAnimationSystem(vrm) {
            console.log('ÂàùÂßãÂåñÂãïÁï´Á≥ªÁµ±...');
            
            // ÂâµÂª∫ÂëºÂê∏ÂãïÁï´
            const breathClip = createBreathClip(vrm);
            if (breathClip) {
                breathAction = currentMixer.clipAction(breathClip);
                breathAction.setLoop(THREE.LoopRepeat);
                breathAction.play();
                console.log('ÂëºÂê∏ÂãïÁï´Â∑≤ÂïüÂãï');
            }

            // ÂâµÂª∫Áú®ÁúºÂãïÁï´
            const blinkClip = createBlinkClip(vrm);
            if (blinkClip) {
                blinkAction = currentMixer.clipAction(blinkClip);
                blinkAction.setLoop(THREE.LoopRepeat);
                blinkAction.play();
                console.log('Áú®ÁúºÂãïÁï´Â∑≤ÂïüÂãï');
            }

            // ÂâµÂª∫ÈñíÁΩÆÂãïÁï´ÁÆ°ÁêÜÂô®
            idleAnimationManager = new IdleAnimationManager(vrm, currentMixer);

            // ÈñãÂßãÈñíÁΩÆÂãïÁï´Âæ™Áí∞
            startIdleAnimationLoop();
            
            console.log('ÂãïÁï´Á≥ªÁµ±ÂàùÂßãÂåñÂÆåÊàê');
        }

        // ============= ÂâµÂª∫Á®ãÂ∫èÂåñÈñíÁΩÆÂãïÁï´ =============
        function createIdleClip(vrm) {
            const tracks = [];
            const fps = 30;
            const duration = 6; // 6ÁßíÂë®Êúü
            const frameCount = duration * fps;
            
            // ÁîüÊàêÊôÇÈñìÊï∏ÁµÑ
            const times = [];
            for (let i = 0; i <= frameCount; i++) {
                times.push(i / fps);
            }
            
            // VRMÁâàÊú¨Ê™¢Ê∏¨
            const v = isVRM1 ? 1 : -1;
            
            // ÈúÄË¶ÅÂãïÁï´ÁöÑÈ™®È™ºÂàóË°®
            const animatedBones = [
                'spine', 'chest', 'neck', 'head',
                'leftUpperArm', 'leftLowerArm', 'leftHand', 'leftShoulder',
                'rightUpperArm', 'rightLowerArm', 'rightHand', 'rightShoulder'
            ];
            
            animatedBones.forEach(boneName => {
                const bone = vrm.humanoid?.getNormalizedBoneNode(boneName);
                if (!bone) return;
                
                const values = [];
                
                // ÁÇ∫ÊØèÂÄãÊôÇÈñìÈªûË®àÁÆóÊóãËΩâÂÄº
                times.forEach(time => {
                    let euler = new THREE.Euler(0, 0, 0);
                    
                    // ‰ΩøÁî®Âë®ÊúüÊÄßÂáΩÊï∏ÔºåÁ¢∫‰øùÂú® t=0 Âíå t=duration ÊôÇÂÄºÁõ∏Âêå
                    const cycleTime = (time / duration) * 2 * Math.PI; // 0 Âà∞ 2œÄ
                    
                    switch (boneName) {
                        case 'spine':
                            euler.set(
                                Math.sin(cycleTime * 0.6 + idleOffsets.body) * 0.02,     
                                0,                                                    
                                Math.cos(cycleTime * 0.5 + idleOffsets.body) * 0.015    
                            );
                            break;
                            
                        case 'chest':
                            euler.set(
                                Math.sin(cycleTime * 0.6 + idleOffsets.body) * 0.01,     
                                0,                                                    
                                Math.cos(cycleTime * 0.5 + idleOffsets.body) * 0.0075   
                            );
                            break;
                            
                        case 'neck':
                            euler.set(
                                Math.cos(cycleTime * 1.2 + idleOffsets.head) * 0.01,     
                                Math.sin(cycleTime * 1.4 + idleOffsets.head) * 0.02,     
                                0                                                     
                            );
                            break;
                            
                        case 'head':
                            euler.set(
                                Math.sin(cycleTime * 1.0 + idleOffsets.head) * 0.02,     
                                Math.sin(cycleTime * 1.4 + idleOffsets.head) * 0.03,     
                                Math.cos(cycleTime * 0.8 + idleOffsets.head) * 0.01      
                            );
                            break;
                            
                        case 'leftUpperArm':
                            euler.set(
                                Math.cos(cycleTime * 0.7 + idleOffsets.leftArm) * 0.03, 
                                Math.sin(cycleTime * 0.6 + idleOffsets.leftArm) * 0.02,  
                                -0.4 * Math.PI * v + Math.sin(cycleTime * 1.5 + idleOffsets.leftArm) * 0.03
                            );
                            break;
                            
                        case 'leftLowerArm':
                            euler.set(
                                0,                                                   
                                0,                                                   
                                -Math.sin(cycleTime * 1.5 + idleOffsets.leftArm) * 0.02 
                            );
                            break;
                            
                        case 'leftHand':
                            euler.set(
                                0.05,                                                
                                0,                                                   
                                0.1 * v + Math.sin(cycleTime * 1.2 + idleOffsets.leftArm) * 0.015 
                            );
                            break;
                            
                        case 'leftShoulder':
                            euler.set(
                                0,                                                   
                                0,                                                   
                                Math.sin(cycleTime * 0.7 + idleOffsets.leftArm) * 0.02 
                            );
                            break;
                            
                        case 'rightUpperArm':
                            euler.set(
                                Math.cos(cycleTime * 0.8 + idleOffsets.rightArm) * 0.03,  
                                Math.sin(cycleTime * 0.64 + idleOffsets.rightArm) * 0.02, 
                                0.4 * Math.PI * v + Math.sin(cycleTime * 1.5 + idleOffsets.rightArm) * 0.03 
                            );
                            break;
                            
                        case 'rightLowerArm':
                            euler.set(
                                0,                                                    
                                0,                                                    
                                Math.sin(cycleTime * 1.5 + idleOffsets.rightArm) * 0.02 
                            );
                            break;
                            
                        case 'rightHand':
                            euler.set(
                                0.05,                                                 
                                0,                                                    
                                -0.1 * v + Math.sin(cycleTime * 1.2 + idleOffsets.rightArm) * 0.015 
                            );
                            break;
                            
                        case 'rightShoulder':
                            euler.set(
                                0,                                                    
                                0,                                                    
                                Math.sin(cycleTime * 0.8 + idleOffsets.rightArm) * 0.02  
                            );
                            break;
                            
                        default:
                            euler.set(0, 0, 0);
                            break;
                    }
                    
                    // Â∞áÊ≠êÊãâËßíËΩâÊèõÁÇ∫ÂõõÂÖÉÊï∏‰∏¶Ê∑ªÂä†Âà∞ÂÄºÊï∏ÁµÑ
                    const quaternion = new THREE.Quaternion();
                    quaternion.setFromEuler(euler);
                    values.push(...quaternion.toArray());
                });
                
                // ÂâµÂª∫ÂõõÂÖÉÊï∏ÈóúÈçµÂπÄËªåÈÅì
                const track = new THREE.QuaternionKeyframeTrack(
                    bone.name + '.quaternion',
                    times,
                    values
                );
                
                tracks.push(track);
            });
            
            // ÂâµÂª∫‰∏¶ËøîÂõûÂãïÁï´Ââ™ËºØ
            return new THREE.AnimationClip('idle', duration, tracks);
        }

        // ============= ÂâµÂª∫ÂëºÂê∏ÂãïÁï´ =============
        function createBreathClip(vrm) {
            const tracks = [];
            const duration = 4; // 4Áßí‰∏ÄÂÄãÂëºÂê∏Âë®Êúü
            const fps = 30;
            const frameCount = duration * fps;
            
            const times = [];
            for (let i = 0; i <= frameCount; i++) {
                times.push(i / fps);
            }
            
            // ÂëºÂê∏Á∏ÆÊîæÂãïÁï´
            const scaleValues = [];
            times.forEach(time => {
                const breathScale = 1 + Math.sin(time * Math.PI / 2) * 0.006; // Êõ¥Ëá™ÁÑ∂ÁöÑÂëºÂê∏ÁØÄÂ•è
                scaleValues.push(breathScale, breathScale, breathScale);
            });
            
            const scaleTrack = new THREE.VectorKeyframeTrack(
                vrm.scene.name + '.scale',
                times,
                scaleValues
            );
            
            tracks.push(scaleTrack);
            return new THREE.AnimationClip('breath', duration, tracks);
        }

        // ============= ÂâµÂª∫Áú®ÁúºÂãïÁï´ =============
        function createBlinkClip(vrm) {
            if (!vrm.expressionManager) return null;
            
            const tracks = [];
            const duration = 6; // 6ÁßíÂë®ÊúüÔºåÂåÖÂê´Èö®Ê©üÈñìÈöî
            const fps = 30;
            const frameCount = duration * fps;
            
            const times = [];
            for (let i = 0; i <= frameCount; i++) {
                times.push(i / fps);
            }
            
            // ÂâµÂª∫Áú®ÁúºÊ®°ÂºèÔºöÂú®Èö®Ê©üÊôÇÈñìÈªûÁú®Áúº
            const blinkValues = [];
            times.forEach(time => {
                let blinkValue = 0;
                
                // Âú®Á¨¨1.5ÁßíÂñÆÊ¨°Áú®Áúº
                if (time >= 1.4 && time <= 1.6) {
                    const progress = (time - 1.4) / 0.2;
                    blinkValue = Math.sin(progress * Math.PI);
                }
                // Âú®Á¨¨4ÁßíÈõôÊ¨°Áú®Áúº
                else if (time >= 3.8 && time <= 4.4) {
                    const localTime = time - 3.8;
                    if (localTime < 0.15) {
                        blinkValue = Math.sin((localTime / 0.15) * Math.PI);
                    } else if (localTime > 0.25 && localTime < 0.4) {
                        blinkValue = Math.sin(((localTime - 0.25) / 0.15) * Math.PI);
                    }
                }
                
                blinkValues.push(blinkValue);
            });
            
            // ÂòóË©¶Áç≤ÂèñÁú®ÁúºË°®ÊÉÖËªåÈÅìÂêçÁ®±
            const blinkTrackName = vrm.expressionManager.getExpressionTrackName?.('blink') || 'blink';
            
            const blinkTrack = new THREE.NumberKeyframeTrack(
                blinkTrackName,
                times,
                blinkValues
            );
            
            tracks.push(blinkTrack);
            return new THREE.AnimationClip('blink', duration, tracks);
        }

        // ============= ÂãïÁï´Êí≠ÊîæËôïÁêÜ =============
        async function handlePlayAnimation(data) {
            const { animationId, animationData } = data;
            
            if (!currentVrm || !currentMixer) {
                console.error('VRM Êàñ Mixer Â∞öÊú™ÂàùÂßãÂåñ');
                return;
            }

            try {
                console.log('Playing animation:', animationId);
                
                // ËºâÂÖ•ÂãïÁï´Ê™îÊ°à
                const animationPath = animationData.path || `/vrm/animations/${animationId}.vrma`;
                await loadAndPlayAnimation(animationPath);
                
            } catch (error) {
                console.error('Êí≠ÊîæÂãïÁï´Â§±Êïó:', error);
            }
        }

        async function loadAndPlayAnimation(animationPath) {
            try {
                const loader = new GLTFLoader();
                loader.register((parser) => {
                    return new VRMAnimationLoaderPlugin(parser);
                });

                return new Promise((resolve, reject) => {
                    loader.load(
                        animationPath,
                        (gltf) => {
                            const vrmAnimations = gltf.userData.vrmAnimations;
                            if (vrmAnimations && vrmAnimations.length > 0 && currentVrm) {
                                // ÂÅúÊ≠¢ÊâÄÊúâÊ≠£Âú®Êí≠ÊîæÁöÑÂãïÁï´
                                currentMixer.stopAllAction();
                                
                                // ÂâµÂª∫ VRM ÂãïÁï´Ââ™ËºØ
                                const clip = createVRMAnimationClip(vrmAnimations[0], currentVrm);
                                
                                if (clip) {
                                    // Êí≠ÊîæÂãïÁï´
                                    const action = currentMixer.clipAction(clip);
                                    action.reset();
                                    action.fadeIn(0.5);
                                    action.setLoop(THREE.LoopOnce);
                                    action.clampWhenFinished = true;
                                    action.play();

                                    // ÂãïÁï´ÁµêÊùüÂæåÁöÑËôïÁêÜ
                                    const onFinished = () => {
                                        action.fadeOut(0.5);
                                        currentMixer.removeEventListener('finished', onFinished);
                                        console.log('ÂãïÁï´Êí≠ÊîæÂÆåÁï¢');
                                    };
                                    
                                    currentMixer.addEventListener('finished', onFinished);
                                    
                                    console.log('ÂãïÁï´ÈñãÂßãÊí≠Êîæ');
                                    resolve(action);
                                } else {
                                    reject(new Error('ÁÑ°Ê≥ïÂâµÂª∫ÂãïÁï´Ââ™ËºØ'));
                                }
                            } else {
                                reject(new Error('Êâæ‰∏çÂà∞ VRM ÂãïÁï´Êï∏Êìö'));
                            }
                        },
                        undefined,
                        (error) => {
                            console.error('ËºâÂÖ•ÂãïÁï´Ê™îÊ°àÂ§±Êïó:', error);
                            reject(error);
                        }
                    );
                });
            } catch (error) {
                console.error('ÂãïÁï´ËºâÂÖ•ÈåØË™§:', error);
                throw error;
            }
        }

        // ============= Â≠óÂπïÊéßÂà∂ =============
        function showSubtitle(text) {
            subtitleElement.textContent = text;
            subtitleElement.style.display = 'block';
        }

        function hideSubtitle() {
            subtitleElement.style.display = 'none';
        }

        function initSubtitleDrag() {
            let isDragging = false;
            let startX, startY, initialX, initialY;

            subtitleElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                
                const rect = subtitleElement.getBoundingClientRect();
                initialX = rect.left + rect.width / 2;
                initialY = rect.top;
                
                subtitleElement.style.cursor = 'grabbing';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;

                const newX = ((initialX + deltaX) / window.innerWidth) * 100;
                const newY = ((initialY + deltaY) / window.innerHeight) * 100;

                subtitleElement.style.left = `${Math.max(10, Math.min(90, newX))}%`;
                subtitleElement.style.bottom = 'auto';
                subtitleElement.style.top = `${Math.max(5, Math.min(90, newY))}%`;
                subtitleElement.style.transform = 'translateX(-50%)';
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    subtitleElement.style.cursor = 'move';
                }
            });
        }

        // ============= ÈüøÊáâÂºè =============
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ============= ÂàùÂßãÂåñ =============
        async function init() {
            try {
                console.log('ÈñãÂßãÂàùÂßãÂåñ...');
                initScene();
                console.log('Â†¥ÊôØÂàùÂßãÂåñÂÆåÊàê');
                animate();
                console.log('ÂãïÁï´Âæ™Áí∞Â∑≤ÂïüÂãï');

                // ÈÄ£Êé• WebSocket
                connectWebSocket();
                console.log('WebSocket ÈÄ£Êé•Â∑≤Âª∫Á´ã');

                // ÂæûÂæåÁ´ØÁç≤ÂèñÁï∂ÂâçÈÅ∏ÊìáÁöÑ VRM
                console.log('Áç≤ÂèñÁï∂ÂâçÈÅ∏ÊìáÁöÑ VRM...');
                let vrmPath = '/vrm/Alice.vrm'; // È†êË®≠ÂÄº
                try {
                    const response = await fetch('/api/vrm/current');
                    if (response.ok) {
                        const data = await response.json();
                        vrmPath = data.path;
                        console.log('ÂæûÂæåÁ´ØÁç≤ÂèñÂà∞ VRM Ë∑ØÂæë:', vrmPath);
                    } else {
                        console.warn('ÁÑ°Ê≥ïÁç≤ÂèñÁï∂Ââç VRMÔºå‰ΩøÁî®È†êË®≠ÂÄº');
                    }
                } catch (error) {
                    console.warn('Áç≤ÂèñÁï∂Ââç VRM Â§±ÊïóÔºå‰ΩøÁî®È†êË®≠ÂÄº:', error);
                }

                // ËºâÂÖ• VRM
                console.log('ÈñãÂßãËºâÂÖ• VRM:', vrmPath);
                await loadVRM(vrmPath);
                console.log('VRM ËºâÂÖ•ÂÆåÊàê');

                // Èö±ËóèËºâÂÖ•Áï´Èù¢
                loadingElement.style.display = 'none';

                console.log('‚úÖ Initialization complete');
            } catch (error) {
                console.error('‚ùå Initialization error:', error);
                loadingElement.innerHTML = '<div class="spinner"></div><div>ËºâÂÖ•Â§±Êïó: ' + error.message + '</div>';
            }
        }

        // ÂïüÂãï
        init();
    </script>
</body>
</html>
