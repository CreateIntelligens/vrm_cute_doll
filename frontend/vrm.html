<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VRM Display</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #subtitle-container {
            position: fixed;
            bottom: 30%;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 8px;
            font-size: 18px;
            max-width: 80%;
            text-align: center;
            word-wrap: break-word;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            display: none;
            z-index: 1000;
            cursor: move;
            user-select: none;
        }

        #connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 20px;
            font-size: 14px;
            z-index: 1001;
        }

        .status-connected {
            background: rgba(34, 197, 94, 0.8) !important;
        }

        .status-disconnected {
            background: rgba(239, 68, 68, 0.8) !important;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-align: center;
            z-index: 999;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="subtitle-container"></div>
    <div id="connection-status">é€£ç·šä¸­...</div>
    <div id="loading">
        <div class="spinner"></div>
        <div>è¼‰å…¥ä¸­...</div>
    </div>

    <!-- Three.js å’Œ VRM ç›¸é—œåº« -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.169.0/examples/jsm/",
            "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@3.1.6/lib/three-vrm.module.min.js",
            "@pixiv/three-vrm-animation": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm-animation@3.1.6/lib/three-vrm-animation.module.min.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { VRMAnimationLoaderPlugin, createVRMAnimationClip } from '@pixiv/three-vrm-animation';

        // ============= å…¨å±€è®Šé‡ =============
        let scene, camera, renderer, controls;
        let currentVrm = null;
        let currentMixer = null;
        let clock = new THREE.Clock();
        let ws = null;
        let audioContext = null;
        let currentAudio = null;
        let subtitleElement = null;
        let statusElement = null;
        let loadingElement = null;

        // ============= å‹•ç•«ç³»çµ±è®Šé‡ =============
        let isVRM1 = true;
        let idleAction = null;
        let breathAction = null;
        let blinkAction = null;
        let idleAnimationManager = null;
        let useVRMAIdleAnimations = true;
        let idleAnimations = [];
        let isLoadingAnimations = false;
        let isIdleAnimationModeChanging = false;

        // é—²ç½®åŠ¨ä½œçš„æ—¶é—´åç§»é‡ï¼Œè®©å„ä¸ªåŠ¨ä½œä¸åŒæ­¥
        const idleOffsets = {
            body: Math.random() * Math.PI * 2,
            leftArm: Math.random() * Math.PI * 2,
            rightArm: Math.random() * Math.PI * 2,
            head: Math.random() * Math.PI * 2,
            spine: Math.random() * Math.PI * 2
        };

        // ============= åˆå§‹åŒ–å ´æ™¯ =============
        function initScene() {
            const container = document.getElementById('canvas-container');
            
            // å ´æ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x212121);

            // ç›¸æ©Ÿ
            camera = new THREE.PerspectiveCamera(
                30,
                window.innerWidth / window.innerHeight,
                0.1,
                20
            );
            camera.position.set(0, 1.3, 2);

            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);

            // æ§åˆ¶å™¨
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 1.3, 0);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.update();

            // ç‡ˆå…‰
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(1, 1, 1).normalize();
            scene.add(light);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            // åœ°æ¿
            const geometry = new THREE.PlaneGeometry(10, 10);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.8,
                metalness: 0.2
            });
            const floor = new THREE.Mesh(geometry, material);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // å­—å¹•å…ƒç´ 
            subtitleElement = document.getElementById('subtitle-container');
            statusElement = document.getElementById('connection-status');
            loadingElement = document.getElementById('loading');

            // å­—å¹•æ‹–æ›³åŠŸèƒ½
            initSubtitleDrag();

            // éŸ¿æ‡‰å¼
            window.addEventListener('resize', onWindowResize);
        }

        // ============= è‡ªç„¶å§¿å‹¢è¨­å®š =============
        function setNaturalPose(vrm) {
            if (!vrm.humanoid) return;
            let v = 1;
            if (!isVRM1) {
                v = -1;
            }
            
            // å·¦è‡‚è‡ªç„¶ä¸‹å‚
            vrm.humanoid.getNormalizedBoneNode('leftUpperArm').rotation.z = -0.4 * Math.PI * v;

            // å³è‡‚è‡ªç„¶ä¸‹å‚
            vrm.humanoid.getNormalizedBoneNode('rightUpperArm').rotation.z = 0.4 * Math.PI * v;
            
            const leftHand = vrm.humanoid.getNormalizedBoneNode('leftHand');
            if (leftHand) {
                leftHand.rotation.z = 0.1 * v; // æ‰‹è…•è‡ªç„¶å¼¯æ›²
                leftHand.rotation.x = 0.05;
            }
            const rightHand = vrm.humanoid.getNormalizedBoneNode('rightHand');
            if (rightHand) {
                rightHand.rotation.z = -0.1 * v; // æ‰‹è…•è‡ªç„¶å¼¯æ›²
                rightHand.rotation.x = 0.05;
            }
            
            // æ·»åŠ æ‰‹æŒ‡çš„è‡ªç„¶å¼¯æ›²ï¼ˆå¦‚æœæ¨¡å‹æ”¯æŒï¼‰
            const fingerBones = [
                'leftThumbProximal', 'leftThumbIntermediate', 'leftThumbDistal',
                'leftIndexProximal', 'leftIndexIntermediate', 'leftIndexDistal',
                'leftMiddleProximal', 'leftMiddleIntermediate', 'leftMiddleDistal',
                'leftRingProximal', 'leftRingIntermediate', 'leftRingDistal',
                'leftLittleProximal', 'leftLittleIntermediate', 'leftLittleDistal',
                'rightThumbProximal', 'rightThumbIntermediate', 'rightThumbDistal',
                'rightIndexProximal', 'rightIndexIntermediate', 'rightIndexDistal',
                'rightMiddleProximal', 'rightMiddleIntermediate', 'rightMiddleDistal',
                'rightRingProximal', 'rightRingIntermediate', 'rightRingDistal',
                'rightLittleProximal', 'rightLittleIntermediate', 'rightLittleDistal'
            ];

            fingerBones.forEach(boneName => {
                const bone = vrm.humanoid.getNormalizedBoneNode(boneName);
                if (bone) {
                    // æ ¹æ®æ‰‹æŒ‡éƒ¨ä½è®¾ç½®ä¸åŒçš„å¼¯æ›²åº¦
                    if (boneName.includes('Thumb')) {
                        // æ‹‡æŒ‡ç¨å¾®å‘å†…
                        bone.rotation.y = boneName.includes('left') ? 0.35 : -0.35;
                    } else if (boneName.includes('Proximal')) {
                        // è¿‘ç«¯æŒ‡éª¨è½»å¾®å¼¯æ›²
                        bone.rotation.z = boneName.includes('left') ? -0.35 * v : 0.35 * v;
                    } else if (boneName.includes('Intermediate')) {
                        // ä¸­ç«¯æŒ‡éª¨ç¨å¾®å¼¯æ›²
                        bone.rotation.z = boneName.includes('left') ? -0.45 * v : 0.45 * v;
                    } else if (boneName.includes('Distal')) {
                        // è¿œç«¯æŒ‡éª¨è½»å¾®å¼¯æ›²
                        bone.rotation.z = boneName.includes('left') ? -0.3 * v : 0.3 * v;
                    }
                }
            });
        }

        // ============= VRM è¼‰å…¥ =============
        async function loadVRM(modelPath) {
            console.log('Loading VRM:', modelPath);
            
            const loader = new GLTFLoader();
            loader.register((parser) => {
                return new VRMLoaderPlugin(parser, {
                    lookAt: { type: 'bone' }
                });
            });

            return new Promise((resolve, reject) => {
                loader.load(
                    modelPath,
                    (gltf) => {
                        const vrm = gltf.userData.vrm;
                        
                        // ç§»é™¤èˆŠæ¨¡å‹
                        if (currentVrm) {
                            scene.remove(currentVrm.scene);
                            VRMUtils.deepDispose(currentVrm.scene);
                        }

                        // å„ªåŒ–æ¨¡å‹
                        VRMUtils.removeUnnecessaryVertices(gltf.scene);
                        VRMUtils.removeUnnecessaryJoints(gltf.scene);

                        // æè³ªä¿®æ­£
                        vrm.scene.traverse((obj) => {
                            if (obj.material) {
                                if (Array.isArray(obj.material)) {
                                    obj.material.forEach(mat => {
                                        if (mat.transparent) {
                                            mat.depthWrite = false;
                                            mat.alphaTest = 0.5;
                                        }
                                    });
                                } else {
                                    if (obj.material.transparent) {
                                        obj.material.depthWrite = false;
                                        obj.material.alphaTest = 0.5;
                                    }
                                }
                                obj.castShadow = true;
                                obj.receiveShadow = true;
                            }
                        });

                        // å•Ÿç”¨ç‰©ç†æ¨¡æ“¬
                        if (vrm.springBoneManager) {
                            vrm.springBoneManager.reset();
                        }

                        scene.add(vrm.scene);
                        currentVrm = vrm;
                        currentMixer = new THREE.AnimationMixer(vrm.scene);
                        
                        // æ£€æµ‹ VRM ç‰ˆæœ¬
                        isVRM1 = vrm.meta.metaVersion === '1';
                        
                        // è®¾ç½®è‡ªç„¶å§¿åŠ¿
                        setNaturalPose(vrm);
                        
                        // åˆå§‹åŒ–åŠ¨ç”»ç³»ç»Ÿ
                        initAnimationSystem(vrm);

                        console.log('VRM loaded successfully');
                        resolve(vrm);
                    },
                    (progress) => {
                        console.log('Loading progress:', (progress.loaded / progress.total * 100).toFixed(2) + '%');
                    },
                    (error) => {
                        console.error('Error loading VRM:', error);
                        reject(error);
                    }
                );
            });
        }

        // ============= å‹•ç•«å¾ªç’° =============
        function animate() {
            requestAnimationFrame(animate);

            const deltaTime = clock.getDelta();

            // æ›´æ–° VRM
            if (currentVrm) {
                currentVrm.update(deltaTime);
            }

            // æ›´æ–° Mixer
            if (currentMixer) {
                currentMixer.update(deltaTime);
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // ============= WebSocket é€£ç·š =============
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws/vrm`;
            
            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('WebSocket connected');
                statusElement.textContent = 'å·²é€£ç·š';
                statusElement.className = 'status-connected';
                
                // å¿ƒè·³
                setInterval(() => {
                    if (ws.readyState === WebSocket.OPEN) {
                        ws.send('ping');
                    }
                }, 30000);
            };

            ws.onmessage = async (event) => {
                try {
                    // ğŸ”§ ä¿®å¾©ï¼šæª¢æŸ¥æ˜¯å¦ç‚ºç´”æ–‡æœ¬æ¶ˆæ¯ï¼ˆå¦‚"pong"ï¼‰
                    if (event.data === 'pong') {
                        console.log('ğŸ”Š [DEBUG] Received pong from server');
                        return;
                    }

                    // å˜—è©¦è§£æJSONæ¶ˆæ¯
                    const message = JSON.parse(event.data);
                    console.log('ğŸ”Š [DEBUG] Received message:', message.type);

                    if (message.type === 'speak') {
                        await handleSpeak(message.data);
                    } else if (message.type === 'switch_model') {
                        await loadVRM(message.data.path);
                    } else if (message.type === 'reset_expression') {
                        resetAllExpressions();
                    } else if (message.type === 'play_animation') {
                        console.log('å‹•ç•«åŠŸèƒ½æš«æ™‚ä¸å¯ç”¨');
                    } else if (message.type === 'config_updated') {
                        // ğŸ”§ æ–°å¢ï¼šé…ç½®æ›´æ–°é€šçŸ¥
                        console.log('ğŸ”„ Animation config updated, reloading...');
                        await reloadAnimationConfiguration();
                    }
                } catch (error) {
                    console.error('ğŸ”Š [ERROR] Error handling WebSocket message:', error);
                    console.error('ğŸ”Š [ERROR] Raw message data:', event.data);
                }
            };

            ws.onclose = () => {
                console.log('WebSocket disconnected');
                statusElement.textContent = 'é€£ç·šä¸­æ–·';
                statusElement.className = 'status-disconnected';
                
                // é‡é€£
                setTimeout(connectWebSocket, 3000);
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };
        }

        // ============= TTS æ’­æ”¾å’Œå£å‹åŒæ­¥ =============
        let currentExpression = null;
        let frameCount = 0;

        async function handleSpeak(data) {
            const { chunkId, text, expression, audioData, mimeType } = data;

            console.log('Speaking:', text);

            // é¡¯ç¤ºå­—å¹•
            showSubtitle(text);

            // é‡ç½®ä¹‹å‰çš„è¡¨æƒ…ï¼Œé¿å…è¡çª
            if (currentVrm && currentVrm.expressionManager) {
                currentVrm.expressionManager.setValue('aa', 0);
                currentVrm.expressionManager.setValue('ih', 0);
                
                // é‡ç½®å…¶ä»–è¡¨æƒ…
                ['happy', 'angry', 'sad', 'surprised', 'relaxed'].forEach(exp => {
                    currentVrm.expressionManager.setValue(exp, 0);
                });
            }

            // è¨­å®šæ–°çš„è¡¨æƒ…
            currentExpression = null;
            if (expression && currentVrm) {
                const validExpressions = ['happy', 'angry', 'sad', 'neutral', 'surprised', 'relaxed'];
                if (validExpressions.includes(expression)) {
                    currentExpression = expression;
                    
                    // é…ç½®è¡¨æƒ…å’Œå£å‹çš„è¡çªè™•ç†
                    if (currentVrm.expressionManager) {
                        // è¨­ç½®å£å‹è¡¨æƒ…ç‚ºå¯è¦†è“‹
                        currentVrm.expressionManager.mouthExpressionNames = ['aa', 'ih'];
                        
                        // ç‚ºç‰¹å®šè¡¨æƒ…è¨­ç½®å£å‹è¦†è“‹å±¬æ€§
                        const mouthOverrideExpressions = ['happy', 'surprised'];
                        mouthOverrideExpressions.forEach(expName => {
                            const exp = currentVrm.expressionManager.getExpression?.(expName);
                            if (exp) {
                                exp.overrideMouth = 'block';
                            }
                        });
                        
                        currentVrm.expressionManager.setValue(expression, 1.0);
                    }
                }
            }

            // æ’­æ”¾éŸ³è¨Š
            if (audioData) {
                await playAudioWithLipSync(audioData, mimeType);
            }
        }

        async function playAudioWithLipSync(audioBase64, mimeType) {
            try {
                console.log('ğŸ”Š [DEBUG] Starting audio playback...');
                console.log('ğŸ”Š [DEBUG] Audio data length:', audioBase64.length);
                console.log('ğŸ”Š [DEBUG] MIME type:', mimeType);

                // åˆå§‹åŒ– AudioContext
                if (!audioContext) {
                    console.log('ğŸ”Š [DEBUG] Creating new AudioContext...');
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                // æª¢æŸ¥ AudioContext ç‹€æ…‹
                if (audioContext.state === 'suspended') {
                    console.log('ğŸ”Š [DEBUG] AudioContext was suspended, resuming...');
                    await audioContext.resume();
                }

                // åœæ­¢ç•¶å‰éŸ³è¨Š
                if (currentAudio) {
                    console.log('ğŸ”Š [DEBUG] Stopping previous audio...');
                    currentAudio.pause();
                    currentAudio.currentTime = 0;
                    currentAudio = null;
                }

                // è§£ç¢¼ base64
                console.log('ğŸ”Š [DEBUG] Decoding base64 audio data...');
                const audioBytes = Uint8Array.from(atob(audioBase64), c => c.charCodeAt(0));
                const audioBlob = new Blob([audioBytes], { type: mimeType });
                const audioUrl = URL.createObjectURL(audioBlob);
                console.log('ğŸ”Š [DEBUG] Created audio URL:', audioUrl);

                // å‰µå»ºéŸ³è¨Šå…ƒç´ 
                const audio = new Audio(audioUrl);
                currentAudio = audio;

                // è¨­ç½®éŸ³è¨Šå±¬æ€§
                audio.volume = 1.0;
                audio.preload = 'auto';

                // ğŸ”§ ä¿®å¾©ï¼šæª¢æŸ¥AudioContextæ˜¯å¦å·²ç¶“é€£æ¥é
                let source, analyser;
                try {
                    console.log('ğŸ”Š [DEBUG] Creating MediaElementSource...');
                    source = audioContext.createMediaElementSource(audio);
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 256;
                    analyser.smoothingTimeConstant = 0.8;

                    source.connect(analyser);
                    analyser.connect(audioContext.destination);
                    console.log('ğŸ”Š [DEBUG] Audio pipeline connected successfully');
                } catch (sourceError) {
                    console.error('ğŸ”Š [ERROR] Failed to create audio source:', sourceError);
                    // å¦‚æœAudioContexté€£æ¥å¤±æ•—ï¼Œç›´æ¥æ’­æ”¾éŸ³é »ï¼ˆç„¡å£å‹åŒæ­¥ï¼‰
                    analyser = null;
                    console.log('ğŸ”Š [DEBUG] Falling back to direct audio playback');
                }

                const bufferLength = analyser ? analyser.frequencyBinCount : 0;
                const dataArray = analyser ? new Uint8Array(bufferLength) : null;

                frameCount = 0;

                // å£å‹åŒæ­¥å‹•ç•«
                const animateLipSync = () => {
                    if (audio.paused || audio.ended) {
                        console.log('ğŸ”Š [DEBUG] Audio ended, resetting expressions...');
                        // æ’­æ”¾çµæŸï¼Œé‡ç½®å£å‹ä½†ä¿æŒå…¶ä»–è¡¨æƒ…
                        if (currentVrm && currentVrm.expressionManager) {
                            currentVrm.expressionManager.setValue('aa', 0);
                            currentVrm.expressionManager.setValue('ih', 0);
                            
                            // ä¿æŒç•¶å‰è¡¨æƒ…ä¸€æ®µæ™‚é–“
                            setTimeout(() => {
                                if (currentVrm && currentVrm.expressionManager) {
                                    ['happy', 'angry', 'sad', 'surprised', 'relaxed'].forEach(exp => {
                                        currentVrm.expressionManager.setValue(exp, 0);
                                    });
                                }
                            }, 2000);
                        }
                        return;
                    }

                    frameCount++;
                    
                    // ğŸ”§ ä¿®å¾©ï¼šæª¢æŸ¥analyseræ˜¯å¦å­˜åœ¨
                    let intensity = 0;
                    if (analyser && dataArray) {
                        try {
                            analyser.getByteFrequencyData(dataArray);
                            
                            // è¨ˆç®—éŸ³é‡ï¼ˆåƒ…ä½¿ç”¨ä¸­ä½é »ï¼‰
                            const relevantData = dataArray.slice(0, Math.floor(bufferLength / 2));
                            const sum = relevantData.reduce((a, b) => a + b, 0);
                            const average = sum / relevantData.length;
                            intensity = Math.min(average / 128, 1.0);
                        } catch (analyserError) {
                            console.error('ğŸ”Š [ERROR] Audio analysis failed:', analyserError);
                            intensity = 0;
                        }
                    } else {
                        // å¦‚æœæ²’æœ‰analyserï¼Œä½¿ç”¨åŸºæœ¬çš„æ™‚é–“é©…å‹•å£å‹å‹•ç•«
                        intensity = Math.sin(frameCount * 0.2) * 0.3 + 0.3; // åŸºæœ¬å£å‹å‹•ç•«
                    }

                    // é©…å‹•å£å‹ - å¤§å¹…é™ä½å¼·åº¦
                    if (currentVrm && currentVrm.expressionManager && intensity > 0.3) {
                        let maxMouthOpen = 0.4; // å¤§å¹…é™ä½æœ€å¤§å¼µå˜´
                        
                        // æ ¹æ“šç•¶å‰è¡¨æƒ…èª¿æ•´å£å‹å¼·åº¦
                        if (currentExpression) {
                            if (['happy', 'surprised'].includes(currentExpression)) {
                                maxMouthOpen = 0.3; // é–‹å¿ƒå’Œé©šè¨è¡¨æƒ…æ™‚é€²ä¸€æ­¥é™ä½
                            } else if (['angry', 'sad'].includes(currentExpression)) {
                                maxMouthOpen = 0.12;
                            }
                            
                            // ä¿æŒç•¶å‰è¡¨æƒ…
                            currentVrm.expressionManager.setValue(currentExpression, 1.0);
                        }
                        
                        const mouthOpen = Math.min(intensity * 0.3, maxMouthOpen); // å¤§å¹…é™ä½å¼·åº¦ä¿‚æ•¸
                        currentVrm.expressionManager.setValue('aa', mouthOpen);
                        
                        // æ·»åŠ ç´°å¾®çš„å£å‹è®ŠåŒ–
                        const variation = Math.sin(frameCount * 0.1) * 0.02;
                        const ihValue = Math.min(Math.max(0, mouthOpen * 0.2 + variation), maxMouthOpen * 0.5);
                        currentVrm.expressionManager.setValue('ih', ihValue);
                    } else if (currentVrm && currentVrm.expressionManager) {
                        // å¹³æ»‘é–‰å˜´
                        const currentAA = currentVrm.expressionManager.getValue?.('aa') || 0;
                        const currentIH = currentVrm.expressionManager.getValue?.('ih') || 0;
                        currentVrm.expressionManager.setValue('aa', Math.max(0, currentAA * 0.7 - 0.01));
                        currentVrm.expressionManager.setValue('ih', Math.max(0, currentIH * 0.6 - 0.005));
                        
                        // ä¿æŒå…¶ä»–è¡¨æƒ…
                        if (currentExpression) {
                            currentVrm.expressionManager.setValue(currentExpression, 1.0);
                        }
                    }

                    requestAnimationFrame(animateLipSync);
                };

                // ğŸ”§ ä¿®å¾©ï¼šæ·»åŠ audioäº‹ä»¶ç›£è½å™¨
                audio.addEventListener('loadstart', () => console.log('ğŸ”Š [DEBUG] Audio loading started...'));
                audio.addEventListener('loadeddata', () => console.log('ğŸ”Š [DEBUG] Audio data loaded'));
                audio.addEventListener('canplay', () => console.log('ğŸ”Š [DEBUG] Audio can start playing'));
                audio.addEventListener('play', () => console.log('ğŸ”Š [DEBUG] Audio playback started'));
                audio.addEventListener('error', (e) => console.error('ğŸ”Š [ERROR] Audio error:', e));

                // æ’­æ”¾éŸ³é »
                console.log('ğŸ”Š [DEBUG] Starting audio playback...');
                try {
                    const playPromise = audio.play();
                    if (playPromise !== undefined) {
                        playPromise
                            .then(() => {
                                console.log('ğŸ”Š [DEBUG] Audio playback started successfully');
                                animateLipSync();
                            })
                            .catch(error => {
                                console.error('ğŸ”Š [ERROR] Audio playback failed:', error);
                                // å³ä½¿æ’­æ”¾å¤±æ•—ï¼Œä¹Ÿè¦éš±è—å­—å¹•
                                setTimeout(() => {
                                    hideSubtitle();
                                }, 3000);
                            });
                    } else {
                        // è€ç‰ˆæœ¬ç€è¦½å™¨
                        animateLipSync();
                    }
                } catch (playError) {
                    console.error('ğŸ”Š [ERROR] Failed to start audio playback:', playError);
                    setTimeout(() => {
                        hideSubtitle();
                    }, 3000);
                }

                // çµæŸæ™‚éš±è—å­—å¹•
                audio.onended = () => {
                    hideSubtitle();
                    URL.revokeObjectURL(audioUrl);
                    currentAudio = null;
                };

            } catch (error) {
                console.error('Error playing audio:', error);
                hideSubtitle();
            }
        }

        // é‡ç½®æ‰€æœ‰è¡¨æƒ…çš„å‡½æ•¸
        function resetAllExpressions() {
            if (currentVrm && currentVrm.expressionManager) {
                console.log('é‡ç½®æ‰€æœ‰è¡¨æƒ…');
                
                // åœæ­¢ç•¶å‰éŸ³è¨Š
                if (currentAudio) {
                    currentAudio.pause();
                    currentAudio = null;
                }
                
                // é‡ç½®æ‰€æœ‰è¡¨æƒ…å€¼
                const allExpressions = ['aa', 'ih', 'happy', 'angry', 'sad', 'neutral', 'surprised', 'relaxed', 'blink'];
                allExpressions.forEach(exp => {
                    currentVrm.expressionManager.setValue(exp, 0);
                });
                
                currentExpression = null;
                frameCount = 0;
                
                console.log('è¡¨æƒ…é‡ç½®å®Œæˆ');
                return true;
            }
            return false;
        }

        // ============= å®Œæ•´çš„ IdleAnimationManager é¡ =============
        class IdleAnimationManager {
            constructor(vrm, mixer) {
                this.vrm = vrm;
                this.mixer = mixer;
                this.currentIdleAction = null;
                this.defaultPoseAction = null;
                this.proceduralIdleAction = null;
                this.isTransitioning = false;
                this.animationQueue = [];
                this.currentIndex = 0;
                this.transitionDuration = 0.8;
                this.pauseBetweenAnimations = 1.5;
                this.idleWeight = 1.0;
                this.isActive = false;
                this.currentMode = 'none';
                
                // å‰µå»ºé»˜èªå§¿å‹¢å‹•ä½œ
                this.createDefaultPoseAction();
                // å‰µå»ºç¨‹åºåŒ–é–’ç½®å‹•ç•«
                this.createProceduralIdleAction();
                
                console.log('IdleAnimationManager initialized');
            }
            
            // å‰µå»ºé»˜èªå§¿å‹¢å‹•ä½œ
            createDefaultPoseAction() {
                try {
                    const defaultPoseClip = this.createDefaultPoseClip();
                    this.defaultPoseAction = this.mixer.clipAction(defaultPoseClip);
                    this.defaultPoseAction.setLoop(THREE.LoopOnce);
                    this.defaultPoseAction.clampWhenFinished = true;
                    this.defaultPoseAction.setEffectiveWeight(0);
                    console.log('Default pose action created');
                } catch (error) {
                    console.error('Error creating default pose action:', error);
                }
            }
            
            // å‰µå»ºç¨‹åºåŒ–é–’ç½®å‹•ç•«
            createProceduralIdleAction() {
                try {
                    console.log('Creating procedural idle action...');
                    const idleClip = createIdleClip(this.vrm);
                    if (!idleClip) {
                        console.error('Failed to create idle clip');
                        return;
                    }
                    
                    this.proceduralIdleAction = this.mixer.clipAction(idleClip);
                    this.proceduralIdleAction.setLoop(THREE.LoopRepeat);
                    this.proceduralIdleAction.setEffectiveWeight(0);
                    
                    console.log('Procedural idle action created successfully');
                } catch (error) {
                    console.error('Error creating procedural idle action:', error);
                }
            }
            
            // å‰µå»ºé»˜èªå§¿å‹¢clip
            createDefaultPoseClip() {
                const tracks = [];
                const duration = 1.0;
                const fps = 30;
                const frameCount = duration * fps;
                
                const times = [];
                for (let i = 0; i <= frameCount; i++) {
                    times.push(i / fps);
                }
                
                const bonesToReset = [
                    'hips', 'spine', 'chest', 'upperChest', 'neck', 'head',
                    'leftShoulder', 'leftUpperArm', 'leftLowerArm', 'leftHand',
                    'rightShoulder', 'rightUpperArm', 'rightLowerArm', 'rightHand',
                    'leftUpperLeg', 'leftLowerLeg', 'leftFoot', 'leftToes',
                    'rightUpperLeg', 'rightLowerLeg', 'rightFoot', 'rightToes'
                ];
                
                bonesToReset.forEach(boneName => {
                    const bone = this.vrm.humanoid?.getNormalizedBoneNode(boneName);
                    if (!bone) return;
                    
                    const naturalRotation = this.getNaturalRotation(boneName);
                    const values = [];
                    
                    times.forEach((time, index) => {
                        if (index === 0) {
                            values.push(...bone.quaternion.toArray());
                        } else {
                            const progress = time / duration;
                            const easedProgress = this.easeInOutCubic(progress);
                            
                            const currentQuat = new THREE.Quaternion().fromArray(
                                values.slice((index - 1) * 4, index * 4)
                            );
                            
                            const interpolatedQuat = currentQuat.clone().slerp(naturalRotation, easedProgress);
                            values.push(...interpolatedQuat.toArray());
                        }
                    });
                    
                    const track = new THREE.QuaternionKeyframeTrack(
                        bone.name + '.quaternion',
                        times,
                        values
                    );
                    
                    tracks.push(track);
                });
                
                return new THREE.AnimationClip('defaultPose', duration, tracks);
            }
            
            easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }
            
            getNaturalRotation(boneName) {
                const euler = new THREE.Euler(0, 0, 0);
                const v = isVRM1 ? 1 : -1;
                
                switch (boneName) {
                    case 'leftUpperArm':
                        euler.set(0, 0, -0.4 * Math.PI * v);
                        break;
                    case 'rightUpperArm':
                        euler.set(0, 0, 0.4 * Math.PI * v);
                        break;
                    case 'leftHand':
                        euler.set(0.05, 0, 0.1 * v);
                        break;
                    case 'rightHand':
                        euler.set(0.05, 0, -0.1 * v);
                        break;
                    default:
                        euler.set(0, 0, 0);
                        break;
                }
                
                const quaternion = new THREE.Quaternion();
                quaternion.setFromEuler(euler);
                return quaternion;
            }
            
            setAnimationQueue(animations) {
                this.animationQueue = [...animations];
                this.currentIndex = 0;
                console.log(`Idle animation queue set with ${animations.length} animations`);
            }
            
            startIdleLoop() {
                if (this.animationQueue.length === 0) {
                    console.warn('No idle animations available, switching to procedural mode');
                    this.switchToProceduralMode();
                    return;
                }
                
                console.log('Starting VRMA idle animation loop');
                this.currentMode = 'vrma';
                this.isActive = true;
                this.playNextVRMAAnimation();
            }
            
            playNextVRMAAnimation() {
                console.log(`ğŸ® [DEBUG] playNextVRMAAnimation called - isActive: ${this.isActive}, mode: ${this.currentMode}, queueLength: ${this.animationQueue.length}`);
                
                if (!this.isActive || this.currentMode !== 'vrma' || this.animationQueue.length === 0) {
                    console.log(`ğŸš« [DEBUG] Skipping playback - conditions not met`);
                    return;
                }
                
                if (this.isTransitioning) {
                    console.log(`â³ [DEBUG] Still transitioning, retrying in 100ms`);
                    setTimeout(() => this.playNextVRMAAnimation(), 100);
                    return;
                }
                
                const animation = this.animationQueue[this.currentIndex];
                console.log(`ğŸ­ [DEBUG] Playing VRMA animation: ${animation.name} (${this.currentIndex + 1}/${this.animationQueue.length})`);
                console.log(`ğŸ“Š [DEBUG] Animation details:`, {
                    name: animation.name,
                    hasAnimation: !!animation.animation,
                    file: animation.file
                });
                
                this.playVRMAAnimation(animation);
                
                // éš¨æ©Ÿé¸æ“‡ä¸‹ä¸€å€‹å‹•ç•«ï¼ˆé¿å…é‡è¤‡ï¼‰
                const previousIndex = this.currentIndex;
                const length = this.animationQueue.length;

                if (length < 2) {
                    this.currentIndex = 0;
                } else {
                    let newIndex;
                    do {
                        newIndex = Math.floor(Math.random() * length);
                    } while (newIndex === previousIndex);
                    this.currentIndex = newIndex;
                }
                
                console.log(`ğŸ”„ [DEBUG] Next animation index set to: ${this.currentIndex}`);
            }
            
            playVRMAAnimation(animationData) {
                if (!animationData || !animationData.animation) {
                    console.error('Invalid VRMA animation data');
                    this.scheduleNextVRMAAnimation();
                    return;
                }
                
                try {
                    // éœ€è¦å‹•æ…‹åŒ¯å…¥ createVRMAnimationClip
                    import('@pixiv/three-vrm-animation').then(({ createVRMAnimationClip }) => {
                        const clip = createVRMAnimationClip(animationData.animation, this.vrm);
                        if (!clip) {
                            console.error('Failed to create VRMA animation clip');
                            this.scheduleNextVRMAAnimation();
                            return;
                        }
                        
                        this.currentIdleAction = this.mixer.clipAction(clip);
                        this.currentIdleAction.setLoop(THREE.LoopOnce);
                        this.currentIdleAction.clampWhenFinished = true;
                        this.currentIdleAction.fadeIn(1.0);
                        this.currentIdleAction.play();
                        
                        const onFinished = (event) => {
                            if (event.action === this.currentIdleAction) {
                                console.log(`VRMA animation ${animationData.name} finished`);
                                this.onVRMAAnimationFinished();
                                this.mixer.removeEventListener('finished', onFinished);
                            }
                        };
                        
                        this.mixer.addEventListener('finished', onFinished);
                    }).catch(error => {
                        console.error('Failed to load VRM animation library:', error);
                        this.scheduleNextVRMAAnimation();
                    });
                    
                } catch (error) {
                    console.error(`Error playing VRMA animation ${animationData.name}:`, error);
                    this.scheduleNextVRMAAnimation();
                }
            }
            
            onVRMAAnimationFinished() {
                if (this.currentMode !== 'vrma' || !this.isActive) {
                    return;
                }
                
                console.log('VRMA animation finished, transitioning to default pose');
                this.isTransitioning = true;
                
                if (this.currentIdleAction) {
                    this.currentIdleAction.fadeOut(1.0);
                }
                
                if (this.defaultPoseAction) {
                    this.defaultPoseAction.reset();
                    this.defaultPoseAction.setEffectiveWeight(0);
                    this.defaultPoseAction.play();
                    this.defaultPoseAction.fadeIn(this.transitionDuration * 0.5);
                    
                    setTimeout(() => {
                        if (this.defaultPoseAction) {
                            this.defaultPoseAction.setEffectiveWeight(this.idleWeight);
                        }
                    }, this.transitionDuration * 250);
                }
                
                setTimeout(() => {
                    if (this.currentMode !== 'vrma' || !this.isActive) {
                        this.isTransitioning = false;
                        return;
                    }
                    
                    setTimeout(() => {
                        if (this.currentMode !== 'vrma' || !this.isActive) {
                            this.isTransitioning = false;
                            return;
                        }
                        
                        if (this.defaultPoseAction) {
                            this.defaultPoseAction.fadeOut(this.transitionDuration * 0.3);
                        }
                        
                        this.isTransitioning = false;
                        
                        setTimeout(() => {
                            if (this.currentMode === 'vrma' && this.isActive) {
                                this.playNextVRMAAnimation();
                            }
                        }, 300);
                        
                    }, this.pauseBetweenAnimations * 1000);
                    
                }, this.transitionDuration * 600);
            }
            
            scheduleNextVRMAAnimation() {
                if (this.currentMode === 'vrma' && this.isActive) {
                    setTimeout(() => {
                        this.playNextVRMAAnimation();
                    }, this.pauseBetweenAnimations * 1000);
                }
            }
            
            switchToVRMAMode() {
                console.log('Switching to VRMA idle animations');
                this.stopProceduralAnimations();
                
                if (this.animationQueue.length > 0) {
                    this.startIdleLoop();
                } else {
                    console.warn('No VRMA animations available, falling back to procedural');
                    this.switchToProceduralMode();
                }
            }
            
            switchToProceduralMode() {
                console.log('Switching to procedural idle animation');
                this.stopVRMAAnimations();
                
                this.currentMode = 'procedural';
                this.isActive = true;
                
                if (this.proceduralIdleAction) {
                    if (this.proceduralIdleAction.isRunning()) {
                        this.proceduralIdleAction.setEffectiveWeight(this.idleWeight);
                    } else {
                        this.proceduralIdleAction.reset();
                        this.proceduralIdleAction.setEffectiveWeight(this.idleWeight);
                        this.proceduralIdleAction.play();
                    }
                }
            }
            
            stopVRMAAnimations() {
                console.log('Stopping VRMA animations only');
                const fadeTime = 0.5;
                
                if (this.currentIdleAction && this.currentIdleAction.isRunning()) {
                    this.currentIdleAction.fadeOut(fadeTime);
                    setTimeout(() => {
                        if (this.currentIdleAction) {
                            this.currentIdleAction.stop();
                            this.currentIdleAction = null;
                        }
                    }, fadeTime * 1000);
                }
                
                if (this.defaultPoseAction && this.defaultPoseAction.isRunning()) {
                    this.defaultPoseAction.fadeOut(fadeTime);
                }
            }
            
            stopProceduralAnimations() {
                console.log('Stopping procedural animations only');
                const fadeTime = 0.5;
                
                if (this.proceduralIdleAction && this.proceduralIdleAction.isRunning()) {
                    this.proceduralIdleAction.fadeOut(fadeTime);
                    setTimeout(() => {
                        if (this.proceduralIdleAction) {
                            this.proceduralIdleAction.stop();
                        }
                    }, fadeTime * 1000);
                }
            }
            
            stopAllAnimations() {
                console.log('Stopping all idle animations');
                this.isActive = false;
                this.isTransitioning = false;
                
                const fadeTime = 0.5;
                
                if (this.currentIdleAction && this.currentIdleAction.isRunning()) {
                    this.currentIdleAction.fadeOut(fadeTime);
                    setTimeout(() => {
                        if (this.currentIdleAction) {
                            this.currentIdleAction.stop();
                            this.currentIdleAction = null;
                        }
                    }, fadeTime * 1000);
                }
                
                if (this.proceduralIdleAction && this.proceduralIdleAction.isRunning()) {
                    this.proceduralIdleAction.fadeOut(fadeTime);
                    setTimeout(() => {
                        if (this.proceduralIdleAction) {
                            this.proceduralIdleAction.stop();
                        }
                    }, fadeTime * 1000);
                }
                
                if (this.defaultPoseAction && this.defaultPoseAction.isRunning()) {
                    this.defaultPoseAction.fadeOut(fadeTime);
                    setTimeout(() => {
                        if (this.defaultPoseAction) {
                            this.defaultPoseAction.stop();
                        }
                    }, fadeTime * 1000);
                }
                
                this.currentMode = 'none';
            }
        }

        // ============= é…ç½®é‡è¼‰å‡½æ•¸ =============
        async function reloadAnimationConfiguration() {
            if (!idleAnimationManager) {
                console.warn('Animation manager not available for reload');
                return;
            }

            try {
                console.log('ğŸ”„ Reloading animation configuration...');
                
                // é‡æ–°è¼‰å…¥å‹•ç•«é…ç½®
                const animationFiles = await getAnimationFiles();
                
                // åœæ­¢ç•¶å‰å‹•ç•«
                idleAnimationManager.stopAllAnimations();
                
                // æ¸…ç©ºç•¶å‰å‹•ç•«æ•¸æ“š
                idleAnimations = [];
                isLoadingAnimations = false;
                
                // é‡æ–°è¼‰å…¥å‹•ç•«
                if (animationFiles.length > 0) {
                    console.log('ğŸ“ Loading new animation configuration...');
                    await loadIdleAnimations();
                    
                    if (idleAnimations.length > 0) {
                        idleAnimationManager.setAnimationQueue(idleAnimations);
                        idleAnimationManager.switchToVRMAMode();
                        console.log('âœ… Animation configuration reloaded successfully!');
                    } else {
                        console.warn('âš ï¸  No valid animations loaded, switching to procedural');
                        idleAnimationManager.switchToProceduralMode();
                    }
                } else {
                    console.log('â„¹ï¸  No animations selected, switching to procedural mode');
                    idleAnimationManager.switchToProceduralMode();
                }
                
            } catch (error) {
                console.error('âŒ Failed to reload animation configuration:', error);
                // å¤±æ•—æ™‚å›åˆ°ç¨‹åºåŒ–å‹•ç•«
                if (idleAnimationManager) {
                    idleAnimationManager.switchToProceduralMode();
                }
            }
        }

        // ============= å‹•ç•«è¼‰å…¥å’Œç®¡ç†å‡½æ•¸ =============
        async function getAnimationFiles() {
            try {
                console.log('ğŸ”„ [DEBUG] Fetching animation configuration from server...');
                const response = await fetch('/api/vrm/config');
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                const config = data.VRMConfig;
                
                if (!config) {
                    throw new Error('Invalid config response: missing VRMConfig');
                }
                
                // ç²å–é¸ä¸­çš„å‹•ç•« ID
                const selectedMotionIds = config.selectedMotionIds || [];
                console.log('âœ… [DEBUG] Selected motion IDs from server:', selectedMotionIds);
                console.log('ğŸ“Š [DEBUG] Config details:', {
                    selectedCount: selectedMotionIds.length,
                    defaultMotionsCount: config.defaultMotions.length,
                    userMotionsCount: config.userMotions.length
                });
                
                // å¦‚æœæ²’æœ‰é¸ä¸­çš„å‹•ç•«ï¼Œè¿”å›ç©ºæ•¸çµ„ï¼ˆå°‡ä½¿ç”¨ç¨‹åºåŒ–å‹•ç•«ï¼‰
                if (selectedMotionIds.length === 0) {
                    console.log('â„¹ï¸  [DEBUG] No animations selected, will use procedural animations only');
                    return [];
                }
                
                // ç²å–æ‰€æœ‰å¯ç”¨å‹•ç•«
                const allMotions = [...config.defaultMotions, ...config.userMotions];
                console.log('ğŸ“ [DEBUG] Available motions:', allMotions.map(m => `${m.id}:${m.name}`));
                
                // æ ¹æ“šé¸ä¸­çš„ ID ç¯©é¸å‹•ç•«ä¸¦æ§‹é€ å®Œæ•´ URL
                const selectedAnimations = selectedMotionIds
                    .map(id => {
                        const motion = allMotions.find(m => m.id === id);
                        if (motion) {
                            const url = `${window.location.protocol}//${window.location.host}${motion.path}`;
                            console.log(`âœ… [DEBUG] Found motion: ${id} -> ${url}`);
                            return url;
                        }
                        console.warn(`âš ï¸  [DEBUG] Animation not found: ${id}`);
                        return null;
                    })
                    .filter(url => url !== null);
                
                console.log(`ğŸ­ [DEBUG] Final selected animations (${selectedAnimations.length}):`, selectedAnimations);
                return selectedAnimations;
                
            } catch (error) {
                console.error('âŒ [DEBUG] Error getting animation files from config:', error);
                console.warn('ğŸ”™ [DEBUG] Falling back to procedural animations only (no VRMA files)');
                
                return [];
            }
        }

        async function loadVRMAAnimation(url) {
            return new Promise((resolve, reject) => {
                const loader = new GLTFLoader();
                
                // ğŸ”§ æ­£ç¢ºè¨»å†Š VRMAnimationLoaderPlugin
                loader.register((parser) => {
                    return new VRMAnimationLoaderPlugin(parser);
                });
                
                loader.load(
                    url,
                    (gltf) => {
                        // âœ… çœŸå¯¦è¼‰å…¥ VRM å‹•ç•«æ•¸æ“š
                        const vrmAnimations = gltf.userData.vrmAnimations;
                        if (vrmAnimations && vrmAnimations.length > 0) {
                            console.log(`Successfully loaded animation: ${url.split('/').pop()}`);
                            resolve(vrmAnimations[0]); // è¿”å›ç¬¬ä¸€å€‹å‹•ç•«
                        } else {
                            console.warn(`No VRM animation found in: ${url}`);
                            resolve(null); // æ²’æœ‰å‹•ç•«æ™‚è¿”å› null
                        }
                    },
                    (progress) => {
                        console.log(`Loading animation ${url.split('/').pop()}...`, 
                                  Math.round((progress.loaded / progress.total) * 100), '%');
                    },
                    (error) => {
                        console.error(`Failed to load animation: ${url}`, error);
                        // ğŸ”§ å¤±æ•—æ™‚è¿”å› null è€Œä¸æ˜¯ rejectï¼Œä¿è­‰å…¶ä»–å‹•ç•«èƒ½ç¹¼çºŒè¼‰å…¥
                        resolve(null);
                    }
                );
            });
        }

        async function loadIdleAnimations() {
            if (isLoadingAnimations) return;
            isLoadingAnimations = true;
            
            console.log('Loading idle animations...');
            
            try {
                const animationFiles = await getAnimationFiles();
                idleAnimations = [];
                
                for (const file of animationFiles) {
                    try {
                        const animation = await loadVRMAAnimation(file);
                        if (animation) { // åªæ·»åŠ æˆåŠŸè¼‰å…¥çš„å‹•ç•«
                            idleAnimations.push({
                                animation: animation,
                                file: file,
                                name: file.split('/').pop().replace('.vrma', '')
                            });
                            console.log(`Loaded animation: ${file}`);
                        }
                    } catch (error) {
                        console.warn(`Failed to load animation: ${file}`, error);
                    }
                }
                
                console.log(`Successfully loaded ${idleAnimations.length} idle animations`);
                
            } catch (error) {
                console.error('Error loading idle animations:', error);
            } finally {
                isLoadingAnimations = false;
            }
        }

        async function startIdleAnimationLoop() {
            if (!idleAnimationManager) {
                console.error('Idle animation manager not available');
                return;
            }
            
            console.log(`Starting idle animation with mode: ${useVRMAIdleAnimations ? 'VRMA' : 'Procedural'}`);
            
            if (useVRMAIdleAnimations) {
                if (idleAnimations.length === 0) {
                    console.log('Loading VRMA animations...');
                    await loadIdleAnimations();
                }
                
                if (idleAnimations.length > 0) {
                    idleAnimationManager.setAnimationQueue(idleAnimations);
                    idleAnimationManager.switchToVRMAMode();
                } else {
                    console.warn('No VRMA animations available, falling back to procedural');
                    idleAnimationManager.switchToProceduralMode();
                }
            } else {
                idleAnimationManager.switchToProceduralMode();
            }
        }

        async function toggleIdleAnimationMode() {
            if (isIdleAnimationModeChanging || !idleAnimationManager) {
                return;
            }
            
            isIdleAnimationModeChanging = true;
            useVRMAIdleAnimations = !useVRMAIdleAnimations;
            
            console.log(`Switching idle animation mode to: ${useVRMAIdleAnimations ? 'VRMA' : 'Procedural'}`);
            
            try {
                if (useVRMAIdleAnimations) {
                    if (idleAnimations.length === 0) {
                        await loadIdleAnimations();
                    }
                    
                    if (idleAnimationManager) {
                        idleAnimationManager.setAnimationQueue(idleAnimations);
                        idleAnimationManager.switchToVRMAMode();
                    }
                } else {
                    if (idleAnimationManager) {
                        idleAnimationManager.switchToProceduralMode();
                    }
                }
            } catch (error) {
                console.error('Error switching idle animation mode:', error);
                useVRMAIdleAnimations = !useVRMAIdleAnimations;
            } finally {
                isIdleAnimationModeChanging = false;
            }
        }

        // ============= å‹•ç•«ç³»çµ±åˆå§‹åŒ– =============
        function initAnimationSystem(vrm) {
            console.log('åˆå§‹åŒ–å‹•ç•«ç³»çµ±...');
            
            // å‰µå»ºå‘¼å¸å‹•ç•«
            const breathClip = createBreathClip(vrm);
            if (breathClip) {
                breathAction = currentMixer.clipAction(breathClip);
                breathAction.setLoop(THREE.LoopRepeat);
                breathAction.play();
                console.log('å‘¼å¸å‹•ç•«å·²å•Ÿå‹•');
            }

            // å‰µå»ºçœ¨çœ¼å‹•ç•«
            const blinkClip = createBlinkClip(vrm);
            if (blinkClip) {
                blinkAction = currentMixer.clipAction(blinkClip);
                blinkAction.setLoop(THREE.LoopRepeat);
                blinkAction.play();
                console.log('çœ¨çœ¼å‹•ç•«å·²å•Ÿå‹•');
            }

            // å‰µå»ºé–’ç½®å‹•ç•«ç®¡ç†å™¨
            idleAnimationManager = new IdleAnimationManager(vrm, currentMixer);

            // é–‹å§‹é–’ç½®å‹•ç•«å¾ªç’°
            startIdleAnimationLoop();
            
            console.log('å‹•ç•«ç³»çµ±åˆå§‹åŒ–å®Œæˆ');
        }

        // ============= å‰µå»ºç¨‹åºåŒ–é–’ç½®å‹•ç•« =============
        function createIdleClip(vrm) {
            const tracks = [];
            const fps = 30;
            const duration = 6; // 6ç§’å‘¨æœŸ
            const frameCount = duration * fps;
            
            // ç”Ÿæˆæ™‚é–“æ•¸çµ„
            const times = [];
            for (let i = 0; i <= frameCount; i++) {
                times.push(i / fps);
            }
            
            // VRMç‰ˆæœ¬æª¢æ¸¬
            const v = isVRM1 ? 1 : -1;
            
            // éœ€è¦å‹•ç•«çš„éª¨éª¼åˆ—è¡¨
            const animatedBones = [
                'spine', 'chest', 'neck', 'head',
                'leftUpperArm', 'leftLowerArm', 'leftHand', 'leftShoulder',
                'rightUpperArm', 'rightLowerArm', 'rightHand', 'rightShoulder'
            ];
            
            animatedBones.forEach(boneName => {
                const bone = vrm.humanoid?.getNormalizedBoneNode(boneName);
                if (!bone) return;
                
                const values = [];
                
                // ç‚ºæ¯å€‹æ™‚é–“é»è¨ˆç®—æ—‹è½‰å€¼
                times.forEach(time => {
                    let euler = new THREE.Euler(0, 0, 0);
                    
                    // ä½¿ç”¨å‘¨æœŸæ€§å‡½æ•¸ï¼Œç¢ºä¿åœ¨ t=0 å’Œ t=duration æ™‚å€¼ç›¸åŒ
                    const cycleTime = (time / duration) * 2 * Math.PI; // 0 åˆ° 2Ï€
                    
                    switch (boneName) {
                        case 'spine':
                            euler.set(
                                Math.sin(cycleTime * 0.6 + idleOffsets.body) * 0.02,     
                                0,                                                    
                                Math.cos(cycleTime * 0.5 + idleOffsets.body) * 0.015    
                            );
                            break;
                            
                        case 'chest':
                            euler.set(
                                Math.sin(cycleTime * 0.6 + idleOffsets.body) * 0.01,     
                                0,                                                    
                                Math.cos(cycleTime * 0.5 + idleOffsets.body) * 0.0075   
                            );
                            break;
                            
                        case 'neck':
                            euler.set(
                                Math.cos(cycleTime * 1.2 + idleOffsets.head) * 0.01,     
                                Math.sin(cycleTime * 1.4 + idleOffsets.head) * 0.02,     
                                0                                                     
                            );
                            break;
                            
                        case 'head':
                            euler.set(
                                Math.sin(cycleTime * 1.0 + idleOffsets.head) * 0.02,     
                                Math.sin(cycleTime * 1.4 + idleOffsets.head) * 0.03,     
                                Math.cos(cycleTime * 0.8 + idleOffsets.head) * 0.01      
                            );
                            break;
                            
                        case 'leftUpperArm':
                            euler.set(
                                Math.cos(cycleTime * 0.7 + idleOffsets.leftArm) * 0.03, 
                                Math.sin(cycleTime * 0.6 + idleOffsets.leftArm) * 0.02,  
                                -0.4 * Math.PI * v + Math.sin(cycleTime * 1.5 + idleOffsets.leftArm) * 0.03
                            );
                            break;
                            
                        case 'leftLowerArm':
                            euler.set(
                                0,                                                   
                                0,                                                   
                                -Math.sin(cycleTime * 1.5 + idleOffsets.leftArm) * 0.02 
                            );
                            break;
                            
                        case 'leftHand':
                            euler.set(
                                0.05,                                                
                                0,                                                   
                                0.1 * v + Math.sin(cycleTime * 1.2 + idleOffsets.leftArm) * 0.015 
                            );
                            break;
                            
                        case 'leftShoulder':
                            euler.set(
                                0,                                                   
                                0,                                                   
                                Math.sin(cycleTime * 0.7 + idleOffsets.leftArm) * 0.02 
                            );
                            break;
                            
                        case 'rightUpperArm':
                            euler.set(
                                Math.cos(cycleTime * 0.8 + idleOffsets.rightArm) * 0.03,  
                                Math.sin(cycleTime * 0.64 + idleOffsets.rightArm) * 0.02, 
                                0.4 * Math.PI * v + Math.sin(cycleTime * 1.5 + idleOffsets.rightArm) * 0.03 
                            );
                            break;
                            
                        case 'rightLowerArm':
                            euler.set(
                                0,                                                    
                                0,                                                    
                                Math.sin(cycleTime * 1.5 + idleOffsets.rightArm) * 0.02 
                            );
                            break;
                            
                        case 'rightHand':
                            euler.set(
                                0.05,                                                 
                                0,                                                    
                                -0.1 * v + Math.sin(cycleTime * 1.2 + idleOffsets.rightArm) * 0.015 
                            );
                            break;
                            
                        case 'rightShoulder':
                            euler.set(
                                0,                                                    
                                0,                                                    
                                Math.sin(cycleTime * 0.8 + idleOffsets.rightArm) * 0.02  
                            );
                            break;
                            
                        default:
                            euler.set(0, 0, 0);
                            break;
                    }
                    
                    // å°‡æ­æ‹‰è§’è½‰æ›ç‚ºå››å…ƒæ•¸ä¸¦æ·»åŠ åˆ°å€¼æ•¸çµ„
                    const quaternion = new THREE.Quaternion();
                    quaternion.setFromEuler(euler);
                    values.push(...quaternion.toArray());
                });
                
                // å‰µå»ºå››å…ƒæ•¸é—œéµå¹€è»Œé“
                const track = new THREE.QuaternionKeyframeTrack(
                    bone.name + '.quaternion',
                    times,
                    values
                );
                
                tracks.push(track);
            });
            
            // å‰µå»ºä¸¦è¿”å›å‹•ç•«å‰ªè¼¯
            return new THREE.AnimationClip('idle', duration, tracks);
        }

        // ============= å‰µå»ºå‘¼å¸å‹•ç•« =============
        function createBreathClip(vrm) {
            const tracks = [];
            const duration = 4; // 4ç§’ä¸€å€‹å‘¼å¸å‘¨æœŸ
            const fps = 30;
            const frameCount = duration * fps;
            
            const times = [];
            for (let i = 0; i <= frameCount; i++) {
                times.push(i / fps);
            }
            
            // å‘¼å¸ç¸®æ”¾å‹•ç•«
            const scaleValues = [];
            times.forEach(time => {
                const breathScale = 1 + Math.sin(time * Math.PI / 2) * 0.006; // æ›´è‡ªç„¶çš„å‘¼å¸ç¯€å¥
                scaleValues.push(breathScale, breathScale, breathScale);
            });
            
            const scaleTrack = new THREE.VectorKeyframeTrack(
                vrm.scene.name + '.scale',
                times,
                scaleValues
            );
            
            tracks.push(scaleTrack);
            return new THREE.AnimationClip('breath', duration, tracks);
        }

        // ============= å‰µå»ºçœ¨çœ¼å‹•ç•« =============
        function createBlinkClip(vrm) {
            if (!vrm.expressionManager) return null;
            
            const tracks = [];
            const duration = 6; // 6ç§’å‘¨æœŸï¼ŒåŒ…å«éš¨æ©Ÿé–“éš”
            const fps = 30;
            const frameCount = duration * fps;
            
            const times = [];
            for (let i = 0; i <= frameCount; i++) {
                times.push(i / fps);
            }
            
            // å‰µå»ºçœ¨çœ¼æ¨¡å¼ï¼šåœ¨éš¨æ©Ÿæ™‚é–“é»çœ¨çœ¼
            const blinkValues = [];
            times.forEach(time => {
                let blinkValue = 0;
                
                // åœ¨ç¬¬1.5ç§’å–®æ¬¡çœ¨çœ¼
                if (time >= 1.4 && time <= 1.6) {
                    const progress = (time - 1.4) / 0.2;
                    blinkValue = Math.sin(progress * Math.PI);
                }
                // åœ¨ç¬¬4ç§’é›™æ¬¡çœ¨çœ¼
                else if (time >= 3.8 && time <= 4.4) {
                    const localTime = time - 3.8;
                    if (localTime < 0.15) {
                        blinkValue = Math.sin((localTime / 0.15) * Math.PI);
                    } else if (localTime > 0.25 && localTime < 0.4) {
                        blinkValue = Math.sin(((localTime - 0.25) / 0.15) * Math.PI);
                    }
                }
                
                blinkValues.push(blinkValue);
            });
            
            // å˜—è©¦ç²å–çœ¨çœ¼è¡¨æƒ…è»Œé“åç¨±
            const blinkTrackName = vrm.expressionManager.getExpressionTrackName?.('blink') || 'blink';
            
            const blinkTrack = new THREE.NumberKeyframeTrack(
                blinkTrackName,
                times,
                blinkValues
            );
            
            tracks.push(blinkTrack);
            return new THREE.AnimationClip('blink', duration, tracks);
        }

        // ============= å‹•ç•«æ’­æ”¾è™•ç† =============
        async function handlePlayAnimation(data) {
            const { animationId, animationData } = data;
            
            if (!currentVrm || !currentMixer) {
                console.error('VRM æˆ– Mixer å°šæœªåˆå§‹åŒ–');
                return;
            }

            try {
                console.log('Playing animation:', animationId);
                
                // è¼‰å…¥å‹•ç•«æª”æ¡ˆ
                const animationPath = animationData.path || `/vrm/animations/${animationId}.vrma`;
                await loadAndPlayAnimation(animationPath);
                
            } catch (error) {
                console.error('æ’­æ”¾å‹•ç•«å¤±æ•—:', error);
            }
        }

        async function loadAndPlayAnimation(animationPath) {
            try {
                const loader = new GLTFLoader();
                loader.register((parser) => {
                    return new VRMAnimationLoaderPlugin(parser);
                });

                return new Promise((resolve, reject) => {
                    loader.load(
                        animationPath,
                        (gltf) => {
                            const vrmAnimations = gltf.userData.vrmAnimations;
                            if (vrmAnimations && vrmAnimations.length > 0 && currentVrm) {
                                // åœæ­¢æ‰€æœ‰æ­£åœ¨æ’­æ”¾çš„å‹•ç•«
                                currentMixer.stopAllAction();
                                
                                // å‰µå»º VRM å‹•ç•«å‰ªè¼¯
                                const clip = createVRMAnimationClip(vrmAnimations[0], currentVrm);
                                
                                if (clip) {
                                    // æ’­æ”¾å‹•ç•«
                                    const action = currentMixer.clipAction(clip);
                                    action.reset();
                                    action.fadeIn(0.5);
                                    action.setLoop(THREE.LoopOnce);
                                    action.clampWhenFinished = true;
                                    action.play();

                                    // å‹•ç•«çµæŸå¾Œçš„è™•ç†
                                    const onFinished = () => {
                                        action.fadeOut(0.5);
                                        currentMixer.removeEventListener('finished', onFinished);
                                        console.log('å‹•ç•«æ’­æ”¾å®Œç•¢');
                                    };
                                    
                                    currentMixer.addEventListener('finished', onFinished);
                                    
                                    console.log('å‹•ç•«é–‹å§‹æ’­æ”¾');
                                    resolve(action);
                                } else {
                                    reject(new Error('ç„¡æ³•å‰µå»ºå‹•ç•«å‰ªè¼¯'));
                                }
                            } else {
                                reject(new Error('æ‰¾ä¸åˆ° VRM å‹•ç•«æ•¸æ“š'));
                            }
                        },
                        undefined,
                        (error) => {
                            console.error('è¼‰å…¥å‹•ç•«æª”æ¡ˆå¤±æ•—:', error);
                            reject(error);
                        }
                    );
                });
            } catch (error) {
                console.error('å‹•ç•«è¼‰å…¥éŒ¯èª¤:', error);
                throw error;
            }
        }

        // ============= å­—å¹•æ§åˆ¶ =============
        function showSubtitle(text) {
            subtitleElement.textContent = text;
            subtitleElement.style.display = 'block';
        }

        function hideSubtitle() {
            subtitleElement.style.display = 'none';
        }

        function initSubtitleDrag() {
            let isDragging = false;
            let startX, startY, initialX, initialY;

            subtitleElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                
                const rect = subtitleElement.getBoundingClientRect();
                initialX = rect.left + rect.width / 2;
                initialY = rect.top;
                
                subtitleElement.style.cursor = 'grabbing';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;

                const newX = ((initialX + deltaX) / window.innerWidth) * 100;
                const newY = ((initialY + deltaY) / window.innerHeight) * 100;

                subtitleElement.style.left = `${Math.max(10, Math.min(90, newX))}%`;
                subtitleElement.style.bottom = 'auto';
                subtitleElement.style.top = `${Math.max(5, Math.min(90, newY))}%`;
                subtitleElement.style.transform = 'translateX(-50%)';
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    subtitleElement.style.cursor = 'move';
                }
            });
        }

        // ============= éŸ¿æ‡‰å¼ =============
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ============= åˆå§‹åŒ– =============
        async function init() {
            try {
                console.log('é–‹å§‹åˆå§‹åŒ–...');
                initScene();
                console.log('å ´æ™¯åˆå§‹åŒ–å®Œæˆ');
                animate();
                console.log('å‹•ç•«å¾ªç’°å·²å•Ÿå‹•');
                
                // é€£æ¥ WebSocket
                connectWebSocket();
                console.log('WebSocket é€£æ¥å·²å»ºç«‹');
                
                // è¼‰å…¥é è¨­ VRM
                console.log('é–‹å§‹è¼‰å…¥ VRM...');
                await loadVRM('/vrm/Alice.vrm');
                console.log('VRM è¼‰å…¥å®Œæˆ');
                
                // éš±è—è¼‰å…¥ç•«é¢
                loadingElement.style.display = 'none';
                
                console.log('Initialization complete');
            } catch (error) {
                console.error('Initialization error:', error);
                loadingElement.innerHTML = '<div class="spinner"></div><div>è¼‰å…¥å¤±æ•—: ' + error.message + '</div>';
            }
        }

        // å•Ÿå‹•
        init();
    </script>
</body>
</html>
